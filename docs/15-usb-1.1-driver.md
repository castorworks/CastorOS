# é˜¶æ®µ 15: USB 1.1 é©±åŠ¨

## æ¦‚è¿°

æœ¬é˜¶æ®µå°†å®ç° USB 1.1ï¼ˆUniversal Serial Busï¼‰é©±åŠ¨ï¼Œä¸º CastorOS æä¾› USB è®¾å¤‡æ”¯æŒã€‚USB 1.1 æ”¯æŒä½é€Ÿï¼ˆ1.5 Mbpsï¼‰å’Œå…¨é€Ÿï¼ˆ12 Mbpsï¼‰ä¸¤ç§ä¼ è¾“æ¨¡å¼ï¼Œæ˜¯è¿æ¥é”®ç›˜ã€é¼ æ ‡ã€Uç›˜ç­‰å¤–è®¾çš„é‡è¦æ¥å£ã€‚

**ğŸ“ è®¾è®¡ç†å¿µ**ï¼š

USB é©±åŠ¨æ¶æ„é‡‡ç”¨åˆ†å±‚è®¾è®¡ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    USB è®¾å¤‡é©±åŠ¨å±‚                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  HID é©±åŠ¨    â”‚ â”‚ Mass Storage â”‚ â”‚  Hub é©±åŠ¨    â”‚     â”‚
â”‚  â”‚ (é”®ç›˜/é¼ æ ‡)  â”‚ â”‚   (Uç›˜)      â”‚ â”‚              â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    USB æ ¸å¿ƒå±‚                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ è®¾å¤‡æšä¸¾     â”‚ â”‚ æè¿°ç¬¦è§£æ   â”‚ â”‚ URB ç®¡ç†     â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                  USB ä¸»æœºæ§åˆ¶å™¨é©±åŠ¨                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚  â”‚    UHCI      â”‚ â”‚    OHCI      â”‚ (å¯é€‰,æœªå®ç°)        â”‚
â”‚  â”‚  (Intel)     â”‚ â”‚ (Compaqç­‰)   â”‚                      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      PCI æ€»çº¿                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

æœ¬é˜¶æ®µå®ç°ä»¥ä¸‹æ ¸å¿ƒåŠŸèƒ½ï¼š

âœ… **UHCI ä¸»æœºæ§åˆ¶å™¨é©±åŠ¨**
   - PCI è®¾å¤‡æ£€æµ‹å’Œåˆå§‹åŒ–
   - å¸§åˆ—è¡¨å’Œè°ƒåº¦ç®¡ç†
   - ä¼ è¾“æè¿°ç¬¦ï¼ˆTDï¼‰å’Œé˜Ÿåˆ—å¤´ï¼ˆQHï¼‰ç®¡ç†
   - ä¸­æ–­å¤„ç†

âœ… **USB æ ¸å¿ƒå±‚**
   - USB è®¾å¤‡æšä¸¾
   - æè¿°ç¬¦è§£æï¼ˆè®¾å¤‡ã€é…ç½®ã€æ¥å£ã€ç«¯ç‚¹ï¼‰
   - URBï¼ˆUSB Request Blockï¼‰ç®¡ç†
   - æ§åˆ¶/æ‰¹é‡/ä¸­æ–­ä¼ è¾“æ”¯æŒ

âœ… **USB è®¾å¤‡é©±åŠ¨**
   - Hub é©±åŠ¨ï¼ˆè®¾å¤‡è¿æ¥/æ–­å¼€æ£€æµ‹ï¼‰
   - HID é©±åŠ¨ï¼ˆé”®ç›˜ã€é¼ æ ‡ï¼‰
   - Mass Storage é©±åŠ¨ï¼ˆUç›˜ï¼‰- å¯é€‰

---

## ç›®æ ‡

### é˜¶æ®µ 1: UHCI ä¸»æœºæ§åˆ¶å™¨
- [x] å®ç° PCI è®¾å¤‡æ£€æµ‹ï¼ˆClass 0x0C, Subclass 0x03, ProgIF 0x00ï¼‰
- [x] å®ç° UHCI å¯„å­˜å™¨è®¿é—®ï¼ˆI/O ç«¯å£ï¼‰
- [x] å®ç°å¸§åˆ—è¡¨åˆå§‹åŒ–
- [x] å®ç° TD/QH å†…å­˜æ± ç®¡ç†
- [x] å®ç° UHCI ä¸­æ–­å¤„ç†

### é˜¶æ®µ 2: USB æ ¸å¿ƒå±‚
- [x] å®ç° USB åœ°å€åˆ†é…
- [x] å®ç°æ§åˆ¶ä¼ è¾“ï¼ˆSETUP/DATA/STATUSï¼‰
- [x] å®ç°è®¾å¤‡æè¿°ç¬¦è¯»å–
- [x] å®ç°é…ç½®æè¿°ç¬¦è§£æ
- [x] å®ç°è®¾å¤‡æšä¸¾æµç¨‹

### é˜¶æ®µ 3: USB è®¾å¤‡é©±åŠ¨
- [x] å®ç°çƒ­æ’æ‹”æ”¯æŒï¼ˆç«¯å£çŠ¶æ€æ£€æµ‹ï¼‰
- [ ] å®ç° HID é©±åŠ¨ï¼ˆUSB é”®ç›˜ï¼‰
- [ ] æµ‹è¯• USB é”®ç›˜è¾“å…¥
- [x] å®ç° Mass Storage é©±åŠ¨

### é˜¶æ®µ 4: ç”¨æˆ·ç©ºé—´æ”¯æŒ
- [x] å®ç° `/proc/usb` è™šæ‹Ÿæ–‡ä»¶
- [x] å®ç°ç”¨æˆ·æ€ `lsusb` å‘½ä»¤
- [x] å®ç°å†…æ ¸ Shell USB è°ƒè¯•å‘½ä»¤ï¼ˆ`usb_info`, `uhci_info`, `usb_ls`ï¼‰

---

## æŠ€æœ¯èƒŒæ™¯

### USB 1.1 è§„èŒƒæ¦‚è¿°

**USBï¼ˆUniversal Serial Busï¼‰** æ˜¯ä¸€ç§ä¸²è¡Œæ€»çº¿æ ‡å‡†ï¼Œç”¨äºè¿æ¥è®¡ç®—æœºå’Œå¤–éƒ¨è®¾å¤‡ã€‚

| ç‰ˆæœ¬ | å‘å¸ƒå¹´ä»½ | é€Ÿåº¦ | è¯´æ˜ |
|------|----------|------|------|
| USB 1.0 | 1996 | 1.5/12 Mbps | åˆå§‹ç‰ˆæœ¬ |
| USB 1.1 | 1998 | 1.5/12 Mbps | ä¿®è®¢ç‰ˆæœ¬ï¼Œæé«˜ç¨³å®šæ€§ |
| USB 2.0 | 2000 | 480 Mbps | é«˜é€Ÿæ¨¡å¼ |

**USB 1.1 ä¼ è¾“é€Ÿåº¦**ï¼š
- **ä½é€Ÿï¼ˆLow Speedï¼‰**ï¼š1.5 Mbpsï¼Œç”¨äºé”®ç›˜ã€é¼ æ ‡ç­‰ä½å¸¦å®½è®¾å¤‡
- **å…¨é€Ÿï¼ˆFull Speedï¼‰**ï¼š12 Mbpsï¼Œç”¨äºæ‰“å°æœºã€éŸ³é¢‘è®¾å¤‡ç­‰

**USB ç³»ç»Ÿæ¶æ„**ï¼š
```
ä¸»æœºï¼ˆHostï¼‰              è®¾å¤‡ï¼ˆDeviceï¼‰
    â”‚                        â”‚
    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
    â”œâ”€â”€â”€â†’â”‚  Root Hub   â”‚â†â”€â”€â”€â”€â”¤
    â”‚    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜     â”‚
    â”‚           â”‚            â”‚
    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”     â”‚
    â”‚    â”‚   Hub 1     â”‚     â”‚
    â”‚    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜     â”‚
    â”‚           â”‚            â”‚
    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”     â”‚
    â”‚    â”‚  Device 1   â”‚     â”‚
    â”‚    â”‚  Device 2   â”‚     â”‚
    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚

ä¸»æœºæ§åˆ¶æ•´ä¸ª USB æ€»çº¿ï¼Œæ‰€æœ‰é€šä¿¡ç”±ä¸»æœºå‘èµ·
è®¾å¤‡åªèƒ½åœ¨è¢«ä¸»æœºè¯¢é—®æ—¶å“åº”
```

### USB ä¸»æœºæ§åˆ¶å™¨ç±»å‹

USB 1.x æœ‰ä¸¤ç§ä¸»è¦çš„ä¸»æœºæ§åˆ¶å™¨æ¥å£ï¼š

| ç±»å‹ | è®¾è®¡è€… | ProgIF | ç‰¹ç‚¹ |
|------|--------|--------|------|
| UHCI | Intel | 0x00 | ç®€å•ï¼Œä¾èµ–è½¯ä»¶è°ƒåº¦ |
| OHCI | Compaq/Microsoft/NEC | 0x10 | å¤æ‚ï¼Œç¡¬ä»¶è¾…åŠ©è°ƒåº¦ |

**ThinkPad T41 ä½¿ç”¨ Intel ICH4 èŠ¯ç‰‡ç»„ï¼ŒåŒ…å« UHCI æ§åˆ¶å™¨**ã€‚

### UHCIï¼ˆUniversal Host Controller Interfaceï¼‰

UHCI æ˜¯ Intel è®¾è®¡çš„ USB 1.x ä¸»æœºæ§åˆ¶å™¨æ¥å£ï¼Œç›¸å¯¹ç®€å•ä½†éœ€è¦æ›´å¤šçš„è½¯ä»¶å‚ä¸è°ƒåº¦ã€‚

#### UHCI PCI æ ‡è¯†

```
Vendor ID: 0x8086 (Intel) æˆ–å…¶ä»–å‚å•†
Class Code: 0x0C (Serial Bus Controller)
Subclass: 0x03 (USB Controller)
Prog IF: 0x00 (UHCI)
```

#### UHCI å¯„å­˜å™¨ï¼ˆI/O ç«¯å£è®¿é—®ï¼‰

UHCI ä½¿ç”¨ I/O ç«¯å£è€Œé MMIO è®¿é—®å¯„å­˜å™¨ã€‚å¯„å­˜å™¨åŸºåœ°å€ä» PCI BAR4 è·å–ã€‚

| åç§» | åç§° | å¤§å° | è¯´æ˜ |
|------|------|------|------|
| 0x00 | USBCMD | 16 bit | USB å‘½ä»¤å¯„å­˜å™¨ |
| 0x02 | USBSTS | 16 bit | USB çŠ¶æ€å¯„å­˜å™¨ |
| 0x04 | USBINTR | 16 bit | USB ä¸­æ–­ä½¿èƒ½å¯„å­˜å™¨ |
| 0x06 | FRNUM | 16 bit | å¸§ç¼–å·å¯„å­˜å™¨ |
| 0x08 | FRBASEADD | 32 bit | å¸§åˆ—è¡¨åŸºåœ°å€å¯„å­˜å™¨ |
| 0x0C | SOFMOD | 8 bit | SOF ä¿®æ”¹å¯„å­˜å™¨ |
| 0x10 | PORTSC1 | 16 bit | ç«¯å£ 1 çŠ¶æ€/æ§åˆ¶ |
| 0x12 | PORTSC2 | 16 bit | ç«¯å£ 2 çŠ¶æ€/æ§åˆ¶ |

#### USBCMD å¯„å­˜å™¨ä½å®šä¹‰

```c
#define UHCI_CMD_RS         (1 << 0)    // Run/Stop
#define UHCI_CMD_HCRESET    (1 << 1)    // Host Controller Reset
#define UHCI_CMD_GRESET     (1 << 2)    // Global Reset
#define UHCI_CMD_EGSM       (1 << 3)    // Enter Global Suspend Mode
#define UHCI_CMD_FGR        (1 << 4)    // Force Global Resume
#define UHCI_CMD_SWDBG      (1 << 5)    // Software Debug
#define UHCI_CMD_CF         (1 << 6)    // Configure Flag
#define UHCI_CMD_MAXP       (1 << 7)    // Max Packet (0=32, 1=64)
```

#### USBSTS å¯„å­˜å™¨ä½å®šä¹‰

```c
#define UHCI_STS_USBINT     (1 << 0)    // USB ä¸­æ–­
#define UHCI_STS_ERROR      (1 << 1)    // USB é”™è¯¯ä¸­æ–­
#define UHCI_STS_RD         (1 << 2)    // Resume Detect
#define UHCI_STS_HSE        (1 << 3)    // Host System Error
#define UHCI_STS_HCPE       (1 << 4)    // Host Controller Process Error
#define UHCI_STS_HCH        (1 << 5)    // Host Controller Halted
```

#### PORTSC å¯„å­˜å™¨ä½å®šä¹‰

```c
#define UHCI_PORT_CCS       (1 << 0)    // Current Connect Status
#define UHCI_PORT_CSC       (1 << 1)    // Connect Status Change (W1C)
#define UHCI_PORT_PE        (1 << 2)    // Port Enabled
#define UHCI_PORT_PEC       (1 << 3)    // Port Enable Change (W1C)
#define UHCI_PORT_LS        (3 << 4)    // Line Status (D+/D-)
#define UHCI_PORT_RD        (1 << 6)    // Resume Detect
#define UHCI_PORT_LSDA      (1 << 8)    // Low Speed Device Attached
#define UHCI_PORT_PR        (1 << 9)    // Port Reset
#define UHCI_PORT_SUSP      (1 << 12)   // Suspend
```

#### å¸§åˆ—è¡¨ï¼ˆFrame Listï¼‰

UHCI ä½¿ç”¨ 1024 ä¸ªæ¡ç›®çš„å¸§åˆ—è¡¨è¿›è¡Œè°ƒåº¦ï¼Œæ¯ä¸ªæ¡ç›®æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ˆé“¾æ¥æŒ‡é’ˆï¼‰ã€‚

```
å¸§åˆ—è¡¨ï¼ˆ4KB å¯¹é½ï¼Œ1024 Ã— 4 å­—èŠ‚ = 4KBï¼‰
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Frame 0     â”‚â†’ QH/TD
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Frame 1     â”‚â†’ QH/TD
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ...         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Frame 1023  â”‚â†’ QH/TD
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ¯ 1ms ç¡¬ä»¶è‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªå¸§
å¸§ç¼–å·ä» 0 é€’å¢åˆ° 1023 ç„¶åå¾ªç¯
```

**é“¾æ¥æŒ‡é’ˆæ ¼å¼**ï¼š
```
 31                                        4 3 2 1 0
+------------------------------------------+-+-+-+-+
|        Physical Address (32-byte aligned)  |R|Q|T|
+------------------------------------------+-+-+-+-+

T (Terminate): 1 = ç»ˆæ­¢ï¼Œæ— åç»­å…ƒç´ 
Q (QH/TD Select): 0 = TD, 1 = QH
R: Reserved
```

#### ä¼ è¾“æè¿°ç¬¦ï¼ˆTD - Transfer Descriptorï¼‰

TD æè¿°ä¸€ä¸ª USB æ•°æ®åŒ…ä¼ è¾“ï¼Œå¿…é¡» 16 å­—èŠ‚å¯¹é½ã€‚

```c
typedef struct uhci_td {
    uint32_t link;          // é“¾æ¥æŒ‡é’ˆ
    uint32_t ctrl_status;   // æ§åˆ¶å’ŒçŠ¶æ€
    uint32_t token;         // ä»¤ç‰Œ
    uint32_t buffer;        // æ•°æ®ç¼“å†²åŒºç‰©ç†åœ°å€
    // ä»¥ä¸‹ä¸ºè½¯ä»¶ä½¿ç”¨ï¼ˆç¡¬ä»¶ä¸è®¿é—®ï¼‰
    uint32_t reserved[4];   // å¡«å……åˆ° 32 å­—èŠ‚
} __attribute__((packed, aligned(16))) uhci_td_t;
```

**ctrl_status å­—æ®µ**ï¼š
```
 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15          0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-------------+
|SP|LS| 3E|IOC|IS|LS|NA|CR|TO|BS|ST|RS|DB|      ActLen       |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-------------+

Bit 29: SPD - Short Packet Detect
Bit 28: 3 Errors - 3 é”™è¯¯ååœæ­¢
Bit 27: Low Speed
Bit 26: Isochronous Select
Bit 25: IOC - Interrupt on Complete
Bit 24: Active
Bit 23-18: Error Counter
Bit 17: Stalled
Bit 16: Data Buffer Error
Bits 10-0: Actual Length (ä¼ è¾“çš„å®é™…å­—èŠ‚æ•° - 1)
```

**token å­—æ®µ**ï¼š
```
 31       21 20 19 18      15 14        8 7              0
+-----------+--+--+---------+------------+----------------+
|  MaxLen   |R |D |  EndPt  |  DevAddr   |      PID       |
+-----------+--+--+---------+------------+----------------+

MaxLen: æœ€å¤§åŒ…é•¿åº¦ - 1ï¼ˆ0x7FF = æ— æ•ˆ/ç©ºåŒ…ï¼‰
D: Data Toggle (0 æˆ– 1)
EndPt: ç«¯ç‚¹å· (0-15)
DevAddr: è®¾å¤‡åœ°å€ (0-127)
PID: æ•°æ®åŒ…æ ‡è¯†ç¬¦
    0x2D = OUT (ä¸»æœºâ†’è®¾å¤‡)
    0x69 = IN (è®¾å¤‡â†’ä¸»æœº)
    0xE1 = SETUP (æ§åˆ¶ä¼ è¾“)
```

#### é˜Ÿåˆ—å¤´ï¼ˆQH - Queue Headï¼‰

QH ç”¨äºç»„ç»‡ TDï¼Œæ”¯æŒä¼˜å…ˆçº§è°ƒåº¦ã€‚å¿…é¡» 16 å­—èŠ‚å¯¹é½ã€‚

```c
typedef struct uhci_qh {
    uint32_t head;          // æ°´å¹³é“¾æ¥æŒ‡é’ˆï¼ˆæŒ‡å‘ä¸‹ä¸€ä¸ª QHï¼‰
    uint32_t element;       // å‚ç›´é“¾æ¥æŒ‡é’ˆï¼ˆæŒ‡å‘ TDï¼‰
    // ä»¥ä¸‹ä¸ºè½¯ä»¶ä½¿ç”¨
    uint32_t reserved[2];   // å¡«å……åˆ° 16 å­—èŠ‚
} __attribute__((packed, aligned(16))) uhci_qh_t;
```

**è°ƒåº¦ç»“æ„ç¤ºä¾‹**ï¼š
```
Frame List Entry
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ QH (INT) â”‚â”€â”€â”€â†’â”‚ QH (CTRL)â”‚â”€â”€â”€â†’â”‚ QH (BULK)â”‚â”€â”€â”€â†’ Terminate
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚               â”‚               â”‚
     â–¼               â–¼               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   TD 1   â”‚    â”‚   TD 2   â”‚    â”‚   TD 3   â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚               â”‚               â”‚
     â–¼               â–¼               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    Terminate       Terminate
â”‚   TD 2   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### USB ä¼ è¾“ç±»å‹

USB å®šä¹‰äº†å››ç§ä¼ è¾“ç±»å‹ï¼š

| ç±»å‹ | ç”¨é€” | ç‰¹ç‚¹ | ç¤ºä¾‹ |
|------|------|------|------|
| æ§åˆ¶ï¼ˆControlï¼‰| è®¾å¤‡é…ç½® | å¯é ï¼ŒåŒå‘ | æšä¸¾ã€é…ç½® |
| æ‰¹é‡ï¼ˆBulkï¼‰| å¤§æ•°æ®ä¼ è¾“ | å¯é ï¼Œæ— æ—¶é—´ä¿è¯ | Uç›˜è¯»å†™ |
| ä¸­æ–­ï¼ˆInterruptï¼‰| å°æ•°æ®å‘¨æœŸä¼ è¾“ | å®šæ—¶è½®è¯¢ | é”®ç›˜ã€é¼ æ ‡ |
| ç­‰æ—¶ï¼ˆIsochronousï¼‰| å®æ—¶æ•°æ®æµ | æ— é‡ä¼ ï¼Œå¸¦å®½ä¿è¯ | éŸ³é¢‘ã€è§†é¢‘ |

**æ§åˆ¶ä¼ è¾“é˜¶æ®µ**ï¼š
```
SETUP é˜¶æ®µ â†’ DATA é˜¶æ®µï¼ˆå¯é€‰ï¼‰â†’ STATUS é˜¶æ®µ

SETUP: 8 å­—èŠ‚è¯·æ±‚åŒ…
DATA: 0 æˆ–å¤šä¸ªæ•°æ®åŒ…ï¼ˆæ–¹å‘ç”±è¯·æ±‚å†³å®šï¼‰
STATUS: ç¡®è®¤åŒ…ï¼ˆæ–¹å‘ä¸ DATA ç›¸åï¼‰
```

### USB æè¿°ç¬¦

USB è®¾å¤‡é€šè¿‡æè¿°ç¬¦å‘ä¸»æœºæŠ¥å‘Šè‡ªå·±çš„èƒ½åŠ›ã€‚

#### è®¾å¤‡æè¿°ç¬¦ï¼ˆDevice Descriptorï¼‰

```c
typedef struct usb_device_descriptor {
    uint8_t  bLength;           // æè¿°ç¬¦é•¿åº¦ (18)
    uint8_t  bDescriptorType;   // æè¿°ç¬¦ç±»å‹ (1)
    uint16_t bcdUSB;            // USB ç‰ˆæœ¬ (0x0110 for 1.1)
    uint8_t  bDeviceClass;      // è®¾å¤‡ç±»
    uint8_t  bDeviceSubClass;   // è®¾å¤‡å­ç±»
    uint8_t  bDeviceProtocol;   // è®¾å¤‡åè®®
    uint8_t  bMaxPacketSize0;   // ç«¯ç‚¹ 0 æœ€å¤§åŒ…å¤§å° (8/16/32/64)
    uint16_t idVendor;          // å‚å•† ID
    uint16_t idProduct;         // äº§å“ ID
    uint16_t bcdDevice;         // è®¾å¤‡ç‰ˆæœ¬
    uint8_t  iManufacturer;     // å‚å•†å­—ç¬¦ä¸²ç´¢å¼•
    uint8_t  iProduct;          // äº§å“å­—ç¬¦ä¸²ç´¢å¼•
    uint8_t  iSerialNumber;     // åºåˆ—å·å­—ç¬¦ä¸²ç´¢å¼•
    uint8_t  bNumConfigurations;// é…ç½®æ•°é‡
} __attribute__((packed)) usb_device_descriptor_t;
```

#### é…ç½®æè¿°ç¬¦ï¼ˆConfiguration Descriptorï¼‰

```c
typedef struct usb_configuration_descriptor {
    uint8_t  bLength;           // æè¿°ç¬¦é•¿åº¦ (9)
    uint8_t  bDescriptorType;   // æè¿°ç¬¦ç±»å‹ (2)
    uint16_t wTotalLength;      // æ€»é•¿åº¦ï¼ˆåŒ…å«æ‰€æœ‰æ¥å£å’Œç«¯ç‚¹ï¼‰
    uint8_t  bNumInterfaces;    // æ¥å£æ•°é‡
    uint8_t  bConfigurationValue; // é…ç½®å€¼ï¼ˆç”¨äº SET_CONFIGURATIONï¼‰
    uint8_t  iConfiguration;    // é…ç½®å­—ç¬¦ä¸²ç´¢å¼•
    uint8_t  bmAttributes;      // å±æ€§ï¼ˆè‡ªä¾›ç”µã€è¿œç¨‹å”¤é†’ï¼‰
    uint8_t  bMaxPower;         // æœ€å¤§åŠŸç‡ (å•ä½ 2mA)
} __attribute__((packed)) usb_configuration_descriptor_t;
```

#### æ¥å£æè¿°ç¬¦ï¼ˆInterface Descriptorï¼‰

```c
typedef struct usb_interface_descriptor {
    uint8_t  bLength;           // æè¿°ç¬¦é•¿åº¦ (9)
    uint8_t  bDescriptorType;   // æè¿°ç¬¦ç±»å‹ (4)
    uint8_t  bInterfaceNumber;  // æ¥å£ç¼–å·
    uint8_t  bAlternateSetting; // å¤‡ç”¨è®¾ç½®
    uint8_t  bNumEndpoints;     // ç«¯ç‚¹æ•°é‡
    uint8_t  bInterfaceClass;   // æ¥å£ç±»
    uint8_t  bInterfaceSubClass;// æ¥å£å­ç±»
    uint8_t  bInterfaceProtocol;// æ¥å£åè®®
    uint8_t  iInterface;        // æ¥å£å­—ç¬¦ä¸²ç´¢å¼•
} __attribute__((packed)) usb_interface_descriptor_t;
```

#### ç«¯ç‚¹æè¿°ç¬¦ï¼ˆEndpoint Descriptorï¼‰

```c
typedef struct usb_endpoint_descriptor {
    uint8_t  bLength;           // æè¿°ç¬¦é•¿åº¦ (7)
    uint8_t  bDescriptorType;   // æè¿°ç¬¦ç±»å‹ (5)
    uint8_t  bEndpointAddress;  // ç«¯ç‚¹åœ°å€ï¼ˆbit 7: æ–¹å‘ï¼Œbit 0-3: ç«¯ç‚¹å·ï¼‰
    uint8_t  bmAttributes;      // å±æ€§ï¼ˆä¼ è¾“ç±»å‹ï¼‰
    uint16_t wMaxPacketSize;    // æœ€å¤§åŒ…å¤§å°
    uint8_t  bInterval;         // è½®è¯¢é—´éš”ï¼ˆä¸­æ–­/ç­‰æ—¶ç«¯ç‚¹ï¼‰
} __attribute__((packed)) usb_endpoint_descriptor_t;
```

### USB æ ‡å‡†è¯·æ±‚

æ§åˆ¶ä¼ è¾“ä½¿ç”¨ 8 å­—èŠ‚çš„ SETUP åŒ…ï¼š

```c
typedef struct usb_setup_packet {
    uint8_t  bmRequestType;     // è¯·æ±‚ç±»å‹
    uint8_t  bRequest;          // è¯·æ±‚ä»£ç 
    uint16_t wValue;            // å€¼
    uint16_t wIndex;            // ç´¢å¼•
    uint16_t wLength;           // æ•°æ®é•¿åº¦
} __attribute__((packed)) usb_setup_packet_t;
```

**å¸¸ç”¨æ ‡å‡†è¯·æ±‚**ï¼š

| bRequest | åç§° | ç”¨é€” |
|----------|------|------|
| 0x00 | GET_STATUS | è·å–çŠ¶æ€ |
| 0x01 | CLEAR_FEATURE | æ¸…é™¤ç‰¹æ€§ |
| 0x03 | SET_FEATURE | è®¾ç½®ç‰¹æ€§ |
| 0x05 | SET_ADDRESS | è®¾ç½®è®¾å¤‡åœ°å€ |
| 0x06 | GET_DESCRIPTOR | è·å–æè¿°ç¬¦ |
| 0x08 | GET_CONFIGURATION | è·å–å½“å‰é…ç½® |
| 0x09 | SET_CONFIGURATION | è®¾ç½®é…ç½® |

### USB è®¾å¤‡æšä¸¾æµç¨‹

å½“è®¾å¤‡è¿æ¥æ—¶ï¼Œä¸»æœºæŒ‰ä»¥ä¸‹æµç¨‹æšä¸¾è®¾å¤‡ï¼š

```
1. æ£€æµ‹è®¾å¤‡è¿æ¥ï¼ˆç«¯å£çŠ¶æ€å˜åŒ–ï¼‰
         â”‚
         â–¼
2. å¤ä½ç«¯å£ï¼ˆ100msï¼‰
         â”‚
         â–¼
3. ç¡®å®šè®¾å¤‡é€Ÿåº¦ï¼ˆä½é€Ÿ/å…¨é€Ÿï¼‰
         â”‚
         â–¼
4. è¯»å–è®¾å¤‡æè¿°ç¬¦ï¼ˆåœ°å€ 0ï¼Œè·å– bMaxPacketSize0ï¼‰
         â”‚
         â–¼
5. å¤ä½ç«¯å£ï¼ˆå†æ¬¡ï¼‰
         â”‚
         â–¼
6. åˆ†é…è®¾å¤‡åœ°å€ï¼ˆSET_ADDRESSï¼‰
         â”‚
         â–¼
7. è¯»å–å®Œæ•´è®¾å¤‡æè¿°ç¬¦
         â”‚
         â–¼
8. è¯»å–é…ç½®æè¿°ç¬¦
         â”‚
         â–¼
9. é€‰æ‹©å¹¶è®¾ç½®é…ç½®ï¼ˆSET_CONFIGURATIONï¼‰
         â”‚
         â–¼
10. åŠ è½½è®¾å¤‡é©±åŠ¨
```

### USB è®¾å¤‡ç±»

å¸¸è§ USB è®¾å¤‡ç±»ï¼š

| Class | åç§° | è¯´æ˜ |
|-------|------|------|
| 0x00 | Device | ç±»ä¿¡æ¯åœ¨æ¥å£æè¿°ç¬¦ä¸­ |
| 0x01 | Audio | éŸ³é¢‘è®¾å¤‡ |
| 0x02 | CDC | é€šä¿¡è®¾å¤‡ï¼ˆä¸²å£ï¼‰|
| 0x03 | HID | äººæœºæ¥å£è®¾å¤‡ï¼ˆé”®ç›˜ã€é¼ æ ‡ï¼‰|
| 0x08 | Mass Storage | å¤§å®¹é‡å­˜å‚¨ï¼ˆUç›˜ï¼‰|
| 0x09 | Hub | USB é›†çº¿å™¨ |

---

## å®ç°è®¾è®¡

### 1. æ–‡ä»¶ç»“æ„

```
src/
â”œâ”€â”€ include/
â”‚   â””â”€â”€ drivers/
â”‚       â””â”€â”€ usb/
â”‚           â”œâ”€â”€ usb.h           # USB æ ¸å¿ƒå®šä¹‰
â”‚           â”œâ”€â”€ uhci.h          # UHCI æ§åˆ¶å™¨
â”‚           â”œâ”€â”€ hub.h           # Hub é©±åŠ¨
â”‚           â””â”€â”€ hid.h           # HID é©±åŠ¨
â””â”€â”€ drivers/
    â””â”€â”€ usb/
        â”œâ”€â”€ usb.c               # USB æ ¸å¿ƒå±‚
        â”œâ”€â”€ uhci.c              # UHCI æ§åˆ¶å™¨é©±åŠ¨
        â”œâ”€â”€ hub.c               # Hub é©±åŠ¨
        â””â”€â”€ hid.c               # HID é©±åŠ¨
```

### 2. USB æ ¸å¿ƒå®šä¹‰

**æ–‡ä»¶**: `src/include/drivers/usb/usb.h`

```c
/**
 * @file usb.h
 * @brief USB æ ¸å¿ƒå®šä¹‰
 */

#ifndef _DRIVERS_USB_USB_H_
#define _DRIVERS_USB_USB_H_

#include <types.h>

/* ============================================================================
 * USB è§„èŒƒå¸¸é‡
 * ============================================================================ */

/* USB é€Ÿåº¦ */
#define USB_SPEED_LOW       0   // 1.5 Mbps
#define USB_SPEED_FULL      1   // 12 Mbps

/* ä¼ è¾“ç±»å‹ */
#define USB_TRANSFER_CONTROL    0
#define USB_TRANSFER_ISOCHRONOUS 1
#define USB_TRANSFER_BULK       2
#define USB_TRANSFER_INTERRUPT  3

/* ç«¯ç‚¹æ–¹å‘ */
#define USB_DIR_OUT         0x00
#define USB_DIR_IN          0x80

/* æè¿°ç¬¦ç±»å‹ */
#define USB_DESC_DEVICE         1
#define USB_DESC_CONFIGURATION  2
#define USB_DESC_STRING         3
#define USB_DESC_INTERFACE      4
#define USB_DESC_ENDPOINT       5
#define USB_DESC_HID            0x21
#define USB_DESC_HID_REPORT     0x22

/* æ ‡å‡†è¯·æ±‚ */
#define USB_REQ_GET_STATUS      0x00
#define USB_REQ_CLEAR_FEATURE   0x01
#define USB_REQ_SET_FEATURE     0x03
#define USB_REQ_SET_ADDRESS     0x05
#define USB_REQ_GET_DESCRIPTOR  0x06
#define USB_REQ_SET_DESCRIPTOR  0x07
#define USB_REQ_GET_CONFIGURATION 0x08
#define USB_REQ_SET_CONFIGURATION 0x09
#define USB_REQ_GET_INTERFACE   0x0A
#define USB_REQ_SET_INTERFACE   0x0B

/* è¯·æ±‚ç±»å‹ */
#define USB_REQTYPE_DIR_MASK    0x80
#define USB_REQTYPE_TYPE_MASK   0x60
#define USB_REQTYPE_RECIP_MASK  0x1F

#define USB_REQTYPE_HOST_TO_DEV 0x00
#define USB_REQTYPE_DEV_TO_HOST 0x80

#define USB_REQTYPE_STANDARD    0x00
#define USB_REQTYPE_CLASS       0x20
#define USB_REQTYPE_VENDOR      0x40

#define USB_REQTYPE_DEVICE      0x00
#define USB_REQTYPE_INTERFACE   0x01
#define USB_REQTYPE_ENDPOINT    0x02
#define USB_REQTYPE_OTHER       0x03

/* è®¾å¤‡ç±» */
#define USB_CLASS_HID           0x03
#define USB_CLASS_MASS_STORAGE  0x08
#define USB_CLASS_HUB           0x09

/* PID ç±»å‹ */
#define USB_PID_OUT             0xE1
#define USB_PID_IN              0x69
#define USB_PID_SETUP           0x2D

/* æœ€å¤§å€¼ */
#define USB_MAX_DEVICES         127
#define USB_MAX_ENDPOINTS       16
#define USB_MAX_INTERFACES      8
#define USB_MAX_PACKET_SIZE_LS  8       // ä½é€Ÿæœ€å¤§åŒ…å¤§å°
#define USB_MAX_PACKET_SIZE_FS  64      // å…¨é€Ÿæœ€å¤§åŒ…å¤§å°

/* ============================================================================
 * USB æè¿°ç¬¦ç»“æ„
 * ============================================================================ */

/** è®¾å¤‡æè¿°ç¬¦ */
typedef struct usb_device_descriptor {
    uint8_t  bLength;
    uint8_t  bDescriptorType;
    uint16_t bcdUSB;
    uint8_t  bDeviceClass;
    uint8_t  bDeviceSubClass;
    uint8_t  bDeviceProtocol;
    uint8_t  bMaxPacketSize0;
    uint16_t idVendor;
    uint16_t idProduct;
    uint16_t bcdDevice;
    uint8_t  iManufacturer;
    uint8_t  iProduct;
    uint8_t  iSerialNumber;
    uint8_t  bNumConfigurations;
} __attribute__((packed)) usb_device_descriptor_t;

/** é…ç½®æè¿°ç¬¦ */
typedef struct usb_configuration_descriptor {
    uint8_t  bLength;
    uint8_t  bDescriptorType;
    uint16_t wTotalLength;
    uint8_t  bNumInterfaces;
    uint8_t  bConfigurationValue;
    uint8_t  iConfiguration;
    uint8_t  bmAttributes;
    uint8_t  bMaxPower;
} __attribute__((packed)) usb_configuration_descriptor_t;

/** æ¥å£æè¿°ç¬¦ */
typedef struct usb_interface_descriptor {
    uint8_t  bLength;
    uint8_t  bDescriptorType;
    uint8_t  bInterfaceNumber;
    uint8_t  bAlternateSetting;
    uint8_t  bNumEndpoints;
    uint8_t  bInterfaceClass;
    uint8_t  bInterfaceSubClass;
    uint8_t  bInterfaceProtocol;
    uint8_t  iInterface;
} __attribute__((packed)) usb_interface_descriptor_t;

/** ç«¯ç‚¹æè¿°ç¬¦ */
typedef struct usb_endpoint_descriptor {
    uint8_t  bLength;
    uint8_t  bDescriptorType;
    uint8_t  bEndpointAddress;
    uint8_t  bmAttributes;
    uint16_t wMaxPacketSize;
    uint8_t  bInterval;
} __attribute__((packed)) usb_endpoint_descriptor_t;

/** SETUP åŒ… */
typedef struct usb_setup_packet {
    uint8_t  bmRequestType;
    uint8_t  bRequest;
    uint16_t wValue;
    uint16_t wIndex;
    uint16_t wLength;
} __attribute__((packed)) usb_setup_packet_t;

/* ============================================================================
 * USB è®¾å¤‡å’Œç«¯ç‚¹ç»“æ„
 * ============================================================================ */

/** USB ç«¯ç‚¹ */
typedef struct usb_endpoint {
    uint8_t address;            // ç«¯ç‚¹åœ°å€
    uint8_t type;               // ä¼ è¾“ç±»å‹
    uint16_t max_packet_size;   // æœ€å¤§åŒ…å¤§å°
    uint8_t interval;           // è½®è¯¢é—´éš”
    uint8_t toggle;             // æ•°æ®åˆ‡æ¢ä½
} usb_endpoint_t;

/** USB æ¥å£ */
typedef struct usb_interface {
    uint8_t interface_number;
    uint8_t alternate_setting;
    uint8_t class_code;
    uint8_t subclass_code;
    uint8_t protocol;
    uint8_t num_endpoints;
    usb_endpoint_t endpoints[USB_MAX_ENDPOINTS];
    void *driver_data;          // é©±åŠ¨ç§æœ‰æ•°æ®
} usb_interface_t;

/** USB è®¾å¤‡ */
typedef struct usb_device {
    uint8_t address;            // è®¾å¤‡åœ°å€ (1-127)
    uint8_t speed;              // è®¾å¤‡é€Ÿåº¦
    uint8_t port;               // è¿æ¥çš„ç«¯å£å·
    struct usb_device *parent;  // çˆ¶è®¾å¤‡ï¼ˆHubï¼‰
    
    /* è®¾å¤‡æè¿°ç¬¦ */
    usb_device_descriptor_t device_desc;
    
    /* ç«¯ç‚¹ 0ï¼ˆæ§åˆ¶ç«¯ç‚¹ï¼‰ */
    usb_endpoint_t ep0;
    
    /* æ¥å£ */
    uint8_t num_interfaces;
    usb_interface_t interfaces[USB_MAX_INTERFACES];
    
    /* ä¸»æœºæ§åˆ¶å™¨ */
    void *hc;                   // ä¸»æœºæ§åˆ¶å™¨æŒ‡é’ˆ
    void *hc_data;              // ä¸»æœºæ§åˆ¶å™¨ç§æœ‰æ•°æ®
    
    /* è®¾å¤‡é©±åŠ¨ */
    void *driver;               // è®¾å¤‡é©±åŠ¨
    void *driver_data;          // é©±åŠ¨ç§æœ‰æ•°æ®
} usb_device_t;

/* ============================================================================
 * URBï¼ˆUSB Request Blockï¼‰
 * ============================================================================ */

/** URB çŠ¶æ€ */
#define URB_STATUS_PENDING      0
#define URB_STATUS_COMPLETE     1
#define URB_STATUS_ERROR        -1
#define URB_STATUS_STALL        -2
#define URB_STATUS_TIMEOUT      -3

/** URB æ ‡å¿— */
#define URB_SHORT_NOT_OK        (1 << 0)    // çŸ­åŒ…ä¸ºé”™è¯¯

typedef struct usb_urb usb_urb_t;

/** URB å®Œæˆå›è°ƒ */
typedef void (*urb_complete_t)(usb_urb_t *urb);

/** USB Request Block */
struct usb_urb {
    usb_device_t *device;       // ç›®æ ‡è®¾å¤‡
    usb_endpoint_t *endpoint;   // ç›®æ ‡ç«¯ç‚¹
    
    /* ä¼ è¾“æ•°æ® */
    usb_setup_packet_t setup;   // SETUP åŒ…ï¼ˆæ§åˆ¶ä¼ è¾“ï¼‰
    void *buffer;               // æ•°æ®ç¼“å†²åŒº
    uint32_t buffer_length;     // ç¼“å†²åŒºé•¿åº¦
    uint32_t actual_length;     // å®é™…ä¼ è¾“é•¿åº¦
    
    /* çŠ¶æ€å’Œæ ‡å¿— */
    int status;                 // URB çŠ¶æ€
    uint32_t flags;             // URB æ ‡å¿—
    
    /* å›è°ƒ */
    urb_complete_t complete;    // å®Œæˆå›è°ƒ
    void *context;              // å›è°ƒä¸Šä¸‹æ–‡
    
    /* ä¸»æœºæ§åˆ¶å™¨ä½¿ç”¨ */
    void *hc_data;              // æ§åˆ¶å™¨ç§æœ‰æ•°æ®
    struct usb_urb *next;       // é“¾è¡¨ä¸‹ä¸€ä¸ª
};

/* ============================================================================
 * å‡½æ•°å£°æ˜
 * ============================================================================ */

/**
 * @brief åˆå§‹åŒ– USB å­ç³»ç»Ÿ
 * @return 0 æˆåŠŸï¼Œ-1 å¤±è´¥
 */
int usb_init(void);

/**
 * @brief åˆ†é… USB è®¾å¤‡ç»“æ„
 * @return è®¾å¤‡æŒ‡é’ˆï¼Œå¤±è´¥è¿”å› NULL
 */
usb_device_t *usb_alloc_device(void);

/**
 * @brief é‡Šæ”¾ USB è®¾å¤‡ç»“æ„
 * @param dev è®¾å¤‡æŒ‡é’ˆ
 */
void usb_free_device(usb_device_t *dev);

/**
 * @brief åˆ†é… URB
 * @return URB æŒ‡é’ˆï¼Œå¤±è´¥è¿”å› NULL
 */
usb_urb_t *usb_alloc_urb(void);

/**
 * @brief é‡Šæ”¾ URB
 * @param urb URB æŒ‡é’ˆ
 */
void usb_free_urb(usb_urb_t *urb);

/**
 * @brief æäº¤ URB
 * @param urb URB æŒ‡é’ˆ
 * @return 0 æˆåŠŸï¼Œ-1 å¤±è´¥
 */
int usb_submit_urb(usb_urb_t *urb);

/**
 * @brief åŒæ­¥æ§åˆ¶ä¼ è¾“
 * @param dev è®¾å¤‡
 * @param request_type è¯·æ±‚ç±»å‹
 * @param request è¯·æ±‚ä»£ç 
 * @param value å€¼
 * @param index ç´¢å¼•
 * @param data æ•°æ®ç¼“å†²åŒº
 * @param length æ•°æ®é•¿åº¦
 * @return å®é™…ä¼ è¾“é•¿åº¦ï¼Œ<0 é”™è¯¯
 */
int usb_control_msg(usb_device_t *dev, uint8_t request_type, uint8_t request,
                    uint16_t value, uint16_t index, void *data, uint16_t length);

/**
 * @brief è·å–æè¿°ç¬¦
 * @param dev è®¾å¤‡
 * @param type æè¿°ç¬¦ç±»å‹
 * @param index æè¿°ç¬¦ç´¢å¼•
 * @param buffer ç¼“å†²åŒº
 * @param length ç¼“å†²åŒºé•¿åº¦
 * @return å®é™…é•¿åº¦ï¼Œ<0 é”™è¯¯
 */
int usb_get_descriptor(usb_device_t *dev, uint8_t type, uint8_t index,
                       void *buffer, uint16_t length);

/**
 * @brief è®¾ç½®è®¾å¤‡åœ°å€
 * @param dev è®¾å¤‡
 * @param address æ–°åœ°å€
 * @return 0 æˆåŠŸï¼Œ-1 å¤±è´¥
 */
int usb_set_address(usb_device_t *dev, uint8_t address);

/**
 * @brief è®¾ç½®é…ç½®
 * @param dev è®¾å¤‡
 * @param configuration é…ç½®å€¼
 * @return 0 æˆåŠŸï¼Œ-1 å¤±è´¥
 */
int usb_set_configuration(usb_device_t *dev, uint8_t configuration);

/**
 * @brief è®¾å¤‡æšä¸¾
 * @param dev æ–°è¿æ¥çš„è®¾å¤‡
 * @return 0 æˆåŠŸï¼Œ-1 å¤±è´¥
 */
int usb_enumerate_device(usb_device_t *dev);

/**
 * @brief æ³¨å†Œ USB è®¾å¤‡é©±åŠ¨
 * @param class_code è®¾å¤‡ç±»
 * @param subclass_code è®¾å¤‡å­ç±»ï¼ˆ0xFF åŒ¹é…ä»»æ„ï¼‰
 * @param protocol åè®®ï¼ˆ0xFF åŒ¹é…ä»»æ„ï¼‰
 * @param probe æ¢æµ‹å‡½æ•°
 * @param disconnect æ–­å¼€å‡½æ•°
 * @return 0 æˆåŠŸï¼Œ-1 å¤±è´¥
 */
int usb_register_driver(uint8_t class_code, uint8_t subclass_code, uint8_t protocol,
                        int (*probe)(usb_device_t *, usb_interface_t *),
                        void (*disconnect)(usb_device_t *, usb_interface_t *));

#endif // _DRIVERS_USB_USB_H_
```

### 3. UHCI æ§åˆ¶å™¨å¤´æ–‡ä»¶

**æ–‡ä»¶**: `src/include/drivers/usb/uhci.h`

```c
/**
 * @file uhci.h
 * @brief UHCI (Universal Host Controller Interface) é©±åŠ¨
 */

#ifndef _DRIVERS_USB_UHCI_H_
#define _DRIVERS_USB_UHCI_H_

#include <types.h>
#include <drivers/usb/usb.h>

/* ============================================================================
 * UHCI PCI æ ‡è¯†
 * ============================================================================ */

#define UHCI_PCI_CLASS          0x0C    // Serial Bus Controller
#define UHCI_PCI_SUBCLASS       0x03    // USB Controller
#define UHCI_PCI_PROG_IF        0x00    // UHCI

/* ============================================================================
 * UHCI å¯„å­˜å™¨åç§»ï¼ˆI/O ç«¯å£ï¼‰
 * ============================================================================ */

#define UHCI_REG_USBCMD         0x00    // USB å‘½ä»¤ (16 bit)
#define UHCI_REG_USBSTS         0x02    // USB çŠ¶æ€ (16 bit)
#define UHCI_REG_USBINTR        0x04    // USB ä¸­æ–­ä½¿èƒ½ (16 bit)
#define UHCI_REG_FRNUM          0x06    // å¸§ç¼–å· (16 bit)
#define UHCI_REG_FRBASEADD      0x08    // å¸§åˆ—è¡¨åŸºåœ°å€ (32 bit)
#define UHCI_REG_SOFMOD         0x0C    // SOF ä¿®æ”¹ (8 bit)
#define UHCI_REG_PORTSC1        0x10    // ç«¯å£ 1 çŠ¶æ€/æ§åˆ¶ (16 bit)
#define UHCI_REG_PORTSC2        0x12    // ç«¯å£ 2 çŠ¶æ€/æ§åˆ¶ (16 bit)

/* ============================================================================
 * USBCMD å¯„å­˜å™¨ä½
 * ============================================================================ */

#define UHCI_CMD_RS             (1 << 0)    // Run/Stop
#define UHCI_CMD_HCRESET        (1 << 1)    // Host Controller Reset
#define UHCI_CMD_GRESET         (1 << 2)    // Global Reset
#define UHCI_CMD_EGSM           (1 << 3)    // Enter Global Suspend Mode
#define UHCI_CMD_FGR            (1 << 4)    // Force Global Resume
#define UHCI_CMD_SWDBG          (1 << 5)    // Software Debug
#define UHCI_CMD_CF             (1 << 6)    // Configure Flag
#define UHCI_CMD_MAXP           (1 << 7)    // Max Packet (0=32, 1=64)

/* ============================================================================
 * USBSTS å¯„å­˜å™¨ä½
 * ============================================================================ */

#define UHCI_STS_USBINT         (1 << 0)    // USB ä¸­æ–­
#define UHCI_STS_ERROR          (1 << 1)    // USB é”™è¯¯ä¸­æ–­
#define UHCI_STS_RD             (1 << 2)    // Resume Detect
#define UHCI_STS_HSE            (1 << 3)    // Host System Error
#define UHCI_STS_HCPE           (1 << 4)    // Host Controller Process Error
#define UHCI_STS_HCH            (1 << 5)    // Host Controller Halted

/* ============================================================================
 * USBINTR å¯„å­˜å™¨ä½
 * ============================================================================ */

#define UHCI_INTR_TIMEOUT       (1 << 0)    // Timeout/CRC ä¸­æ–­ä½¿èƒ½
#define UHCI_INTR_RESUME        (1 << 1)    // Resume ä¸­æ–­ä½¿èƒ½
#define UHCI_INTR_IOC           (1 << 2)    // Interrupt on Complete ä½¿èƒ½
#define UHCI_INTR_SP            (1 << 3)    // Short Packet ä¸­æ–­ä½¿èƒ½

/* ============================================================================
 * PORTSC å¯„å­˜å™¨ä½
 * ============================================================================ */

#define UHCI_PORT_CCS           (1 << 0)    // Current Connect Status
#define UHCI_PORT_CSC           (1 << 1)    // Connect Status Change (W1C)
#define UHCI_PORT_PE            (1 << 2)    // Port Enabled
#define UHCI_PORT_PEC           (1 << 3)    // Port Enable Change (W1C)
#define UHCI_PORT_LS_MASK       (3 << 4)    // Line Status
#define UHCI_PORT_LS_SE0        (0 << 4)    // SE0
#define UHCI_PORT_LS_J          (1 << 4)    // J-state (Full Speed)
#define UHCI_PORT_LS_K          (2 << 4)    // K-state (Low Speed)
#define UHCI_PORT_RD            (1 << 6)    // Resume Detect
#define UHCI_PORT_LSDA          (1 << 8)    // Low Speed Device Attached
#define UHCI_PORT_PR            (1 << 9)    // Port Reset
#define UHCI_PORT_SUSP          (1 << 12)   // Suspend

/* ============================================================================
 * é“¾æ¥æŒ‡é’ˆä½
 * ============================================================================ */

#define UHCI_LP_TERM            (1 << 0)    // Terminate
#define UHCI_LP_QH              (1 << 1)    // QH (vs TD)
#define UHCI_LP_DEPTH           (1 << 2)    // Depth/Breadth (ä»… QH)

/* ============================================================================
 * TD æ§åˆ¶/çŠ¶æ€ä½
 * ============================================================================ */

#define UHCI_TD_ACTIVE          (1 << 23)   // Active
#define UHCI_TD_STALLED         (1 << 22)   // Stalled
#define UHCI_TD_DATA_BUFFER_ERR (1 << 21)   // Data Buffer Error
#define UHCI_TD_BABBLE          (1 << 20)   // Babble Detected
#define UHCI_TD_NAK             (1 << 19)   // NAK Received
#define UHCI_TD_TIMEOUT         (1 << 18)   // CRC/Timeout Error
#define UHCI_TD_BITSTUFF        (1 << 17)   // Bitstuff Error
#define UHCI_TD_IOC             (1 << 24)   // Interrupt on Complete
#define UHCI_TD_IOS             (1 << 25)   // Isochronous Select
#define UHCI_TD_LS              (1 << 26)   // Low Speed Device
#define UHCI_TD_CERR_MASK       (3 << 27)   // Error Counter
#define UHCI_TD_CERR_SHIFT      27
#define UHCI_TD_SPD             (1 << 29)   // Short Packet Detect

/* TD Token ä½ */
#define UHCI_TD_PID_OUT         0xE1
#define UHCI_TD_PID_IN          0x69
#define UHCI_TD_PID_SETUP       0x2D

/* ============================================================================
 * UHCI æ•°æ®ç»“æ„
 * ============================================================================ */

#define UHCI_FRAME_LIST_SIZE    1024
#define UHCI_TD_POOL_SIZE       256
#define UHCI_QH_POOL_SIZE       32

/** ä¼ è¾“æè¿°ç¬¦ï¼ˆ16 å­—èŠ‚å¯¹é½ï¼‰ */
typedef struct uhci_td {
    volatile uint32_t link;         // é“¾æ¥æŒ‡é’ˆ
    volatile uint32_t ctrl_status;  // æ§åˆ¶å’ŒçŠ¶æ€
    volatile uint32_t token;        // ä»¤ç‰Œ
    volatile uint32_t buffer;       // æ•°æ®ç¼“å†²åŒºç‰©ç†åœ°å€
    
    /* è½¯ä»¶ä½¿ç”¨ï¼ˆç¡¬ä»¶ä¸è®¿é—®ï¼‰ */
    uint32_t phys_addr;             // æ­¤ TD çš„ç‰©ç†åœ°å€
    usb_urb_t *urb;                 // å…³è”çš„ URB
    struct uhci_td *next;           // é“¾è¡¨ä¸‹ä¸€ä¸ª
    uint32_t pad;                   // å¡«å……åˆ° 32 å­—èŠ‚
} __attribute__((packed, aligned(16))) uhci_td_t;

/** é˜Ÿåˆ—å¤´ï¼ˆ16 å­—èŠ‚å¯¹é½ï¼‰ */
typedef struct uhci_qh {
    volatile uint32_t head;         // æ°´å¹³é“¾æ¥æŒ‡é’ˆ
    volatile uint32_t element;      // å‚ç›´é“¾æ¥æŒ‡é’ˆï¼ˆTDï¼‰
    
    /* è½¯ä»¶ä½¿ç”¨ */
    uint32_t phys_addr;             // æ­¤ QH çš„ç‰©ç†åœ°å€
    uhci_td_t *first_td;            // ç¬¬ä¸€ä¸ª TD
    struct uhci_qh *next;           // é“¾è¡¨ä¸‹ä¸€ä¸ª
    uint32_t pad[3];                // å¡«å……åˆ° 32 å­—èŠ‚
} __attribute__((packed, aligned(16))) uhci_qh_t;

/** UHCI æ§åˆ¶å™¨ç»“æ„ */
typedef struct uhci_controller {
    /* PCI ä¿¡æ¯ */
    uint8_t bus;
    uint8_t slot;
    uint8_t func;
    uint8_t irq;
    
    /* I/O ç«¯å£åŸºåœ°å€ */
    uint16_t io_base;
    
    /* å¸§åˆ—è¡¨ï¼ˆ4KB å¯¹é½ï¼‰ */
    uint32_t *frame_list;           // è™šæ‹Ÿåœ°å€
    uint32_t frame_list_phys;       // ç‰©ç†åœ°å€
    
    /* QH é“¾è¡¨ */
    uhci_qh_t *qh_int;              // ä¸­æ–­ä¼ è¾“ QH
    uhci_qh_t *qh_ctrl;             // æ§åˆ¶ä¼ è¾“ QH
    uhci_qh_t *qh_bulk;             // æ‰¹é‡ä¼ è¾“ QH
    
    /* TD/QH å†…å­˜æ±  */
    uhci_td_t *td_pool;             // TD æ± 
    uhci_qh_t *qh_pool;             // QH æ± 
    uint32_t td_pool_phys;          // TD æ± ç‰©ç†åœ°å€
    uint32_t qh_pool_phys;          // QH æ± ç‰©ç†åœ°å€
    
    /* ç©ºé—²é“¾è¡¨ */
    uhci_td_t *free_tds;            // ç©ºé—² TD é“¾è¡¨
    uhci_qh_t *free_qhs;            // ç©ºé—² QH é“¾è¡¨
    
    /* è®¾å¤‡ç®¡ç† */
    usb_device_t *root_hub;         // æ ¹ Hub è®¾å¤‡
    uint8_t next_address;           // ä¸‹ä¸€ä¸ªå¯ç”¨è®¾å¤‡åœ°å€
    
    /* æŒ‚èµ·çš„ URB */
    usb_urb_t *pending_urbs;        // æŒ‚èµ·çš„ URB é“¾è¡¨
} uhci_controller_t;

/* ============================================================================
 * å‡½æ•°å£°æ˜
 * ============================================================================ */

/**
 * @brief åˆå§‹åŒ– UHCI é©±åŠ¨
 * @return æ£€æµ‹åˆ°çš„æ§åˆ¶å™¨æ•°é‡
 */
int uhci_init(void);

/**
 * @brief è·å– UHCI æ§åˆ¶å™¨
 * @param index æ§åˆ¶å™¨ç´¢å¼•
 * @return æ§åˆ¶å™¨æŒ‡é’ˆï¼Œå¤±è´¥è¿”å› NULL
 */
uhci_controller_t *uhci_get_controller(int index);

/**
 * @brief æäº¤ URB åˆ° UHCI æ§åˆ¶å™¨
 * @param hc æ§åˆ¶å™¨æŒ‡é’ˆ
 * @param urb URB æŒ‡é’ˆ
 * @return 0 æˆåŠŸï¼Œ-1 å¤±è´¥
 */
int uhci_submit_urb(uhci_controller_t *hc, usb_urb_t *urb);

/**
 * @brief å¤ä½ç«¯å£
 * @param hc æ§åˆ¶å™¨
 * @param port ç«¯å£å· (0 æˆ– 1)
 * @return 0 æˆåŠŸï¼Œ-1 å¤±è´¥
 */
int uhci_reset_port(uhci_controller_t *hc, int port);

/**
 * @brief è·å–ç«¯å£çŠ¶æ€
 * @param hc æ§åˆ¶å™¨
 * @param port ç«¯å£å·
 * @return ç«¯å£çŠ¶æ€
 */
uint16_t uhci_get_port_status(uhci_controller_t *hc, int port);

/**
 * @brief æ£€æŸ¥ç«¯å£æ˜¯å¦æœ‰è®¾å¤‡è¿æ¥
 * @param hc æ§åˆ¶å™¨
 * @param port ç«¯å£å·
 * @return true æœ‰è®¾å¤‡è¿æ¥
 */
bool uhci_port_connected(uhci_controller_t *hc, int port);

/**
 * @brief æ£€æŸ¥ç«¯å£æ˜¯å¦ä¸ºä½é€Ÿè®¾å¤‡
 * @param hc æ§åˆ¶å™¨
 * @param port ç«¯å£å·
 * @return true ä½é€Ÿè®¾å¤‡
 */
bool uhci_port_low_speed(uhci_controller_t *hc, int port);

/**
 * @brief æ‰“å° UHCI æ§åˆ¶å™¨ä¿¡æ¯
 * @param hc æ§åˆ¶å™¨æŒ‡é’ˆ
 */
void uhci_print_info(uhci_controller_t *hc);

#endif // _DRIVERS_USB_UHCI_H_
```

### 4. UHCI é©±åŠ¨å®ç°ï¼ˆéª¨æ¶ï¼‰

**æ–‡ä»¶**: `src/drivers/usb/uhci.c`

```c
/**
 * @file uhci.c
 * @brief UHCI (Universal Host Controller Interface) é©±åŠ¨å®ç°
 */

#include <drivers/usb/uhci.h>
#include <drivers/pci.h>
#include <kernel/io.h>
#include <kernel/irq.h>
#include <mm/heap.h>
#include <mm/vmm.h>
#include <lib/klog.h>
#include <lib/string.h>

/* æœ€å¤§æ”¯æŒçš„ UHCI æ§åˆ¶å™¨æ•°é‡ */
#define UHCI_MAX_CONTROLLERS    4

/* å…¨å±€æ§åˆ¶å™¨æ•°ç»„ */
static uhci_controller_t uhci_controllers[UHCI_MAX_CONTROLLERS];
static int uhci_controller_count = 0;

/* ============================================================================
 * å¯„å­˜å™¨è®¿é—®å‡½æ•°
 * ============================================================================ */

static inline uint8_t uhci_read8(uhci_controller_t *hc, uint16_t reg) {
    return inb(hc->io_base + reg);
}

static inline uint16_t uhci_read16(uhci_controller_t *hc, uint16_t reg) {
    return inw(hc->io_base + reg);
}

static inline uint32_t uhci_read32(uhci_controller_t *hc, uint16_t reg) {
    return inl(hc->io_base + reg);
}

static inline void uhci_write8(uhci_controller_t *hc, uint16_t reg, uint8_t val) {
    outb(hc->io_base + reg, val);
}

static inline void uhci_write16(uhci_controller_t *hc, uint16_t reg, uint16_t val) {
    outw(hc->io_base + reg, val);
}

static inline void uhci_write32(uhci_controller_t *hc, uint16_t reg, uint32_t val) {
    outl(hc->io_base + reg, val);
}

/* ============================================================================
 * TD/QH å†…å­˜æ± ç®¡ç†
 * ============================================================================ */

/**
 * @brief åˆå§‹åŒ– TD æ± 
 */
static int uhci_init_td_pool(uhci_controller_t *hc) {
    /* åˆ†é… TD æ± ï¼ˆ16 å­—èŠ‚å¯¹é½ï¼‰ */
    uint32_t size = sizeof(uhci_td_t) * UHCI_TD_POOL_SIZE;
    hc->td_pool = (uhci_td_t *)kmalloc_aligned(size, 16);
    if (!hc->td_pool) {
        return -1;
    }
    memset(hc->td_pool, 0, size);
    
    /* è·å–ç‰©ç†åœ°å€ */
    hc->td_pool_phys = vmm_virt_to_phys((uint32_t)hc->td_pool);
    
    /* åˆå§‹åŒ–ç©ºé—²é“¾è¡¨ */
    hc->free_tds = NULL;
    for (int i = UHCI_TD_POOL_SIZE - 1; i >= 0; i--) {
        uhci_td_t *td = &hc->td_pool[i];
        td->phys_addr = hc->td_pool_phys + i * sizeof(uhci_td_t);
        td->next = hc->free_tds;
        hc->free_tds = td;
    }
    
    return 0;
}

/**
 * @brief åˆ†é… TD
 */
static uhci_td_t *uhci_alloc_td(uhci_controller_t *hc) {
    if (!hc->free_tds) {
        return NULL;
    }
    uhci_td_t *td = hc->free_tds;
    hc->free_tds = td->next;
    memset(td, 0, sizeof(uhci_td_t));
    td->phys_addr = hc->td_pool_phys + ((uint32_t)td - (uint32_t)hc->td_pool);
    return td;
}

/**
 * @brief é‡Šæ”¾ TD
 */
static void uhci_free_td(uhci_controller_t *hc, uhci_td_t *td) {
    td->next = hc->free_tds;
    hc->free_tds = td;
}

/* ============================================================================
 * å¸§åˆ—è¡¨åˆå§‹åŒ–
 * ============================================================================ */

/**
 * @brief åˆå§‹åŒ–å¸§åˆ—è¡¨
 */
static int uhci_init_frame_list(uhci_controller_t *hc) {
    /* åˆ†é…å¸§åˆ—è¡¨ï¼ˆ4KB å¯¹é½ï¼‰ */
    uint32_t size = sizeof(uint32_t) * UHCI_FRAME_LIST_SIZE;
    hc->frame_list = (uint32_t *)kmalloc_aligned(size, 4096);
    if (!hc->frame_list) {
        return -1;
    }
    
    /* è·å–ç‰©ç†åœ°å€ */
    hc->frame_list_phys = vmm_virt_to_phys((uint32_t)hc->frame_list);
    
    /* åˆå§‹åŒ–æ‰€æœ‰å¸§ä¸ºç»ˆæ­¢æŒ‡é’ˆ */
    for (int i = 0; i < UHCI_FRAME_LIST_SIZE; i++) {
        hc->frame_list[i] = UHCI_LP_TERM;
    }
    
    return 0;
}

/* ============================================================================
 * æ§åˆ¶å™¨å¤ä½å’Œåˆå§‹åŒ–
 * ============================================================================ */

/**
 * @brief å¤ä½ UHCI æ§åˆ¶å™¨
 */
static void uhci_reset(uhci_controller_t *hc) {
    /* åœæ­¢æ§åˆ¶å™¨ */
    uhci_write16(hc, UHCI_REG_USBCMD, 0);
    
    /* å…¨å±€å¤ä½ */
    uhci_write16(hc, UHCI_REG_USBCMD, UHCI_CMD_GRESET);
    
    /* ç­‰å¾…è‡³å°‘ 10ms */
    for (volatile int i = 0; i < 100000; i++);
    
    /* æ¸…é™¤å…¨å±€å¤ä½ */
    uhci_write16(hc, UHCI_REG_USBCMD, 0);
    
    /* ä¸»æœºæ§åˆ¶å™¨å¤ä½ */
    uhci_write16(hc, UHCI_REG_USBCMD, UHCI_CMD_HCRESET);
    
    /* ç­‰å¾…å¤ä½å®Œæˆ */
    int timeout = 100;
    while ((uhci_read16(hc, UHCI_REG_USBCMD) & UHCI_CMD_HCRESET) && timeout > 0) {
        for (volatile int i = 0; i < 1000; i++);
        timeout--;
    }
    
    if (timeout == 0) {
        LOG_WARN_MSG("uhci: Reset timeout\n");
    }
    
    /* æ¸…é™¤çŠ¶æ€ */
    uhci_write16(hc, UHCI_REG_USBSTS, 0xFFFF);
}

/**
 * @brief å¯åŠ¨ UHCI æ§åˆ¶å™¨
 */
static void uhci_start(uhci_controller_t *hc) {
    /* è®¾ç½®å¸§åˆ—è¡¨åŸºåœ°å€ */
    uhci_write32(hc, UHCI_REG_FRBASEADD, hc->frame_list_phys);
    
    /* è®¾ç½®å¸§ç¼–å·ä¸º 0 */
    uhci_write16(hc, UHCI_REG_FRNUM, 0);
    
    /* è®¾ç½® SOF ä¿®æ”¹å€¼ */
    uhci_write8(hc, UHCI_REG_SOFMOD, 64);
    
    /* å¯ç”¨ä¸­æ–­ */
    uhci_write16(hc, UHCI_REG_USBINTR, 
                 UHCI_INTR_TIMEOUT | UHCI_INTR_RESUME | 
                 UHCI_INTR_IOC | UHCI_INTR_SP);
    
    /* å¯åŠ¨æ§åˆ¶å™¨ */
    uhci_write16(hc, UHCI_REG_USBCMD, UHCI_CMD_RS | UHCI_CMD_CF | UHCI_CMD_MAXP);
    
    LOG_INFO_MSG("uhci: Controller started\n");
}

/* ============================================================================
 * ç«¯å£æ“ä½œ
 * ============================================================================ */

uint16_t uhci_get_port_status(uhci_controller_t *hc, int port) {
    if (port < 0 || port > 1) return 0;
    uint16_t reg = (port == 0) ? UHCI_REG_PORTSC1 : UHCI_REG_PORTSC2;
    return uhci_read16(hc, reg);
}

bool uhci_port_connected(uhci_controller_t *hc, int port) {
    return (uhci_get_port_status(hc, port) & UHCI_PORT_CCS) != 0;
}

bool uhci_port_low_speed(uhci_controller_t *hc, int port) {
    return (uhci_get_port_status(hc, port) & UHCI_PORT_LSDA) != 0;
}

int uhci_reset_port(uhci_controller_t *hc, int port) {
    if (port < 0 || port > 1) return -1;
    
    uint16_t reg = (port == 0) ? UHCI_REG_PORTSC1 : UHCI_REG_PORTSC2;
    uint16_t status;
    
    /* è®¾ç½®å¤ä½ä½ */
    status = uhci_read16(hc, reg);
    uhci_write16(hc, reg, status | UHCI_PORT_PR);
    
    /* ç­‰å¾…è‡³å°‘ 50ms */
    for (volatile int i = 0; i < 500000; i++);
    
    /* æ¸…é™¤å¤ä½ä½ */
    status = uhci_read16(hc, reg);
    uhci_write16(hc, reg, status & ~UHCI_PORT_PR);
    
    /* ç­‰å¾…å¤ä½å®Œæˆ */
    for (volatile int i = 0; i < 100000; i++);
    
    /* æ¸…é™¤çŠ¶æ€å˜åŒ–ä½å¹¶å¯ç”¨ç«¯å£ */
    status = uhci_read16(hc, reg);
    uhci_write16(hc, reg, status | UHCI_PORT_PE | UHCI_PORT_CSC | UHCI_PORT_PEC);
    
    /* éªŒè¯ç«¯å£å·²å¯ç”¨ */
    status = uhci_read16(hc, reg);
    if (!(status & UHCI_PORT_PE)) {
        LOG_WARN_MSG("uhci: Port %d enable failed\n", port);
        return -1;
    }
    
    LOG_INFO_MSG("uhci: Port %d reset complete, status=0x%04x\n", port, status);
    return 0;
}

/* ============================================================================
 * ä¸­æ–­å¤„ç†
 * ============================================================================ */

static void uhci_irq_handler(registers_t *regs) {
    (void)regs;
    
    for (int i = 0; i < uhci_controller_count; i++) {
        uhci_controller_t *hc = &uhci_controllers[i];
        
        uint16_t status = uhci_read16(hc, UHCI_REG_USBSTS);
        if (status == 0) {
            continue;
        }
        
        /* æ¸…é™¤ä¸­æ–­çŠ¶æ€ï¼ˆå†™ 1 æ¸…é™¤ï¼‰ */
        uhci_write16(hc, UHCI_REG_USBSTS, status);
        
        if (status & UHCI_STS_USBINT) {
            /* ä¼ è¾“å®Œæˆä¸­æ–­ - å¤„ç†å®Œæˆçš„ URB */
            LOG_DEBUG_MSG("uhci: Transfer complete interrupt\n");
            // TODO: éå†æŒ‚èµ·çš„ URBï¼Œæ£€æŸ¥å®ŒæˆçŠ¶æ€
        }
        
        if (status & UHCI_STS_ERROR) {
            LOG_WARN_MSG("uhci: USB error interrupt\n");
        }
        
        if (status & UHCI_STS_RD) {
            LOG_DEBUG_MSG("uhci: Resume detect\n");
        }
        
        if (status & UHCI_STS_HSE) {
            LOG_ERROR_MSG("uhci: Host system error!\n");
        }
        
        if (status & UHCI_STS_HCPE) {
            LOG_ERROR_MSG("uhci: Host controller process error!\n");
        }
    }
}

/* ============================================================================
 * è®¾å¤‡æ£€æµ‹å’Œåˆå§‹åŒ–
 * ============================================================================ */

/**
 * @brief åˆå§‹åŒ–å•ä¸ª UHCI æ§åˆ¶å™¨
 */
static int uhci_init_controller(pci_device_t *pci_dev) {
    if (uhci_controller_count >= UHCI_MAX_CONTROLLERS) {
        LOG_WARN_MSG("uhci: Maximum controllers reached\n");
        return -1;
    }
    
    uhci_controller_t *hc = &uhci_controllers[uhci_controller_count];
    memset(hc, 0, sizeof(uhci_controller_t));
    
    /* ä¿å­˜ PCI ä¿¡æ¯ */
    hc->bus = pci_dev->bus;
    hc->slot = pci_dev->slot;
    hc->func = pci_dev->func;
    hc->irq = pci_dev->interrupt_line;
    
    /* è·å– I/O åŸºåœ°å€ï¼ˆBAR4ï¼‰ */
    uint32_t bar4 = pci_get_bar_address(pci_dev, 4);
    if (bar4 == 0 || !pci_bar_is_io(pci_dev, 4)) {
        LOG_ERROR_MSG("uhci: Invalid BAR4\n");
        return -1;
    }
    hc->io_base = (uint16_t)bar4;
    
    /* å¯ç”¨ PCI æ€»çº¿ä¸»æ§å’Œ I/O ç©ºé—´ */
    pci_enable_bus_master(pci_dev);
    pci_enable_io_space(pci_dev);
    
    /* å¤ä½æ§åˆ¶å™¨ */
    uhci_reset(hc);
    
    /* åˆå§‹åŒ–å¸§åˆ—è¡¨ */
    if (uhci_init_frame_list(hc) < 0) {
        LOG_ERROR_MSG("uhci: Failed to init frame list\n");
        return -1;
    }
    
    /* åˆå§‹åŒ– TD æ±  */
    if (uhci_init_td_pool(hc) < 0) {
        LOG_ERROR_MSG("uhci: Failed to init TD pool\n");
        return -1;
    }
    
    /* æ³¨å†Œä¸­æ–­å¤„ç†ç¨‹åº */
    if (hc->irq != 0 && hc->irq != 0xFF) {
        irq_register_handler(hc->irq, uhci_irq_handler);
        irq_enable_line(hc->irq);
    }
    
    /* å¯åŠ¨æ§åˆ¶å™¨ */
    uhci_start(hc);
    
    /* åˆå§‹åŒ–è®¾å¤‡åœ°å€åˆ†é… */
    hc->next_address = 1;
    
    uhci_controller_count++;
    
    LOG_INFO_MSG("uhci: Controller %d initialized (I/O base: 0x%04x, IRQ: %d)\n",
                 uhci_controller_count - 1, hc->io_base, hc->irq);
    
    /* æ£€æŸ¥ç«¯å£è¿æ¥çŠ¶æ€ */
    for (int port = 0; port < 2; port++) {
        if (uhci_port_connected(hc, port)) {
            LOG_INFO_MSG("uhci: Device detected on port %d (%s speed)\n",
                        port, uhci_port_low_speed(hc, port) ? "low" : "full");
        }
    }
    
    return 0;
}

/**
 * @brief åˆå§‹åŒ– UHCI é©±åŠ¨
 */
int uhci_init(void) {
    uhci_controller_count = 0;
    
    /* æ‰«æ PCI æ€»çº¿æŸ¥æ‰¾ UHCI æ§åˆ¶å™¨ */
    int pci_count = pci_get_device_count();
    for (int i = 0; i < pci_count; i++) {
        pci_device_t *dev = pci_get_device(i);
        if (dev && 
            dev->class_code == UHCI_PCI_CLASS &&
            dev->subclass == UHCI_PCI_SUBCLASS &&
            dev->prog_if == UHCI_PCI_PROG_IF) {
            
            LOG_INFO_MSG("uhci: Found UHCI controller at %02x:%02x.%x\n",
                        dev->bus, dev->slot, dev->func);
            uhci_init_controller(dev);
        }
    }
    
    if (uhci_controller_count == 0) {
        LOG_DEBUG_MSG("uhci: No controllers found\n");
        return 0;
    }
    
    LOG_INFO_MSG("uhci: Initialized %d controller(s)\n", uhci_controller_count);
    return uhci_controller_count;
}

uhci_controller_t *uhci_get_controller(int index) {
    if (index < 0 || index >= uhci_controller_count) {
        return NULL;
    }
    return &uhci_controllers[index];
}

void uhci_print_info(uhci_controller_t *hc) {
    kprintf("UHCI Controller Info:\n");
    kprintf("  PCI: %02x:%02x.%x\n", hc->bus, hc->slot, hc->func);
    kprintf("  I/O Base: 0x%04x\n", hc->io_base);
    kprintf("  IRQ: %d\n", hc->irq);
    kprintf("  USBCMD: 0x%04x\n", uhci_read16(hc, UHCI_REG_USBCMD));
    kprintf("  USBSTS: 0x%04x\n", uhci_read16(hc, UHCI_REG_USBSTS));
    kprintf("  FRNUM: %d\n", uhci_read16(hc, UHCI_REG_FRNUM));
    kprintf("  Port 0: 0x%04x\n", uhci_get_port_status(hc, 0));
    kprintf("  Port 1: 0x%04x\n", uhci_get_port_status(hc, 1));
}
```

---

## å†…æ ¸é›†æˆ

### åœ¨ kernel.c ä¸­åˆå§‹åŒ–

```c
// kernel.c

#include <drivers/usb/uhci.h>
#include <drivers/usb/usb.h>

void kernel_main(multiboot_info_t *mbi) {
    // ... å…¶ä»–åˆå§‹åŒ– ...
    
    // ========================================================================
    // é˜¶æ®µ 4: è®¾å¤‡é©±åŠ¨ï¼ˆDevice Driversï¼‰
    // ========================================================================
    
    // ... PCI, ç½‘å¡ç­‰åˆå§‹åŒ– ...
    
    // 4.8 åˆå§‹åŒ– USB å­ç³»ç»Ÿ
    LOG_INFO_MSG("[Stage 4.8] Initializing USB...\n");
    
    // 4.8.1 åˆå§‹åŒ– USB æ ¸å¿ƒå±‚
    usb_init();
    LOG_DEBUG_MSG("  [4.8.1] USB core initialized\n");
    
    // 4.8.2 åˆå§‹åŒ– UHCI æ§åˆ¶å™¨
    int uhci_count = uhci_init();
    if (uhci_count > 0) {
        LOG_INFO_MSG("  [4.8.2] UHCI initialized (%d controller(s))\n", uhci_count);
    } else {
        LOG_DEBUG_MSG("  [4.8.2] No UHCI controller found\n");
    }
    
    // ... ç»§ç»­å…¶ä»–åˆå§‹åŒ– ...
}
```

---

## USB è°ƒè¯•å‘½ä»¤

### å†…æ ¸ Shell å‘½ä»¤

| å‘½ä»¤ | è¯´æ˜ |
|------|------|
| `usb_info` | æ˜¾ç¤º USB å­ç³»ç»Ÿä¿¡æ¯ |
| `uhci_info` | æ˜¾ç¤º UHCI æ§åˆ¶å™¨è¯¦ç»†ä¿¡æ¯ |
| `usb_ls` | åˆ—å‡ºæ‰€æœ‰å·²è¿æ¥çš„ USB è®¾å¤‡ |

### ç”¨æˆ·æ€ Shell å‘½ä»¤

| å‘½ä»¤ | è¯´æ˜ |
|------|------|
| `lsusb` | åˆ—å‡º USB è®¾å¤‡ï¼ˆè¯»å– `/proc/usb`ï¼‰ |
| `lsusb -v` | æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯ï¼ˆé¢„ç•™ï¼‰ |

### /proc/usb è¾“å‡ºæ ¼å¼

```
USB Devices: 2
================================================================================
Bus Addr  VID:PID     Speed   Class       Description
--------------------------------------------------------------------------------
  0    1   0781:5567   Full    08:06       SCSI Storage
          Interface 0: 08:06:50  EPs: 2
  1    2   046d:c077   Low     03:01       HID
          Interface 0: 03:01:02  EPs: 1
================================================================================
```

---

## QEMU æµ‹è¯•é…ç½®

### å¯åŠ¨å‘½ä»¤

```bash
# åŸºæœ¬é…ç½®ï¼ˆå¯ç”¨ USB æ§åˆ¶å™¨ï¼‰
qemu-system-i386 -kernel castor.bin \
    -usb \
    -device usb-kbd \
    -serial stdio

# å¯ç”¨ UHCI æ§åˆ¶å™¨å¹¶è¿æ¥ USB é”®ç›˜
qemu-system-i386 -kernel castor.bin \
    -machine pc,usb=on \
    -device usb-kbd \
    -serial stdio

# è¿æ¥ USB é¼ æ ‡
qemu-system-i386 -kernel castor.bin \
    -usb \
    -device usb-mouse \
    -serial stdio

# è¿æ¥ USB å­˜å‚¨è®¾å¤‡ï¼ˆUç›˜ï¼‰
qemu-system-i386 -kernel castor.bin \
    -usb \
    -drive if=none,id=usbdisk,file=usbdisk.img,format=raw \
    -device usb-storage,drive=usbdisk \
    -serial stdio

# è°ƒè¯•æ¨¡å¼
qemu-system-i386 -kernel castor.bin \
    -usb \
    -device usb-kbd \
    -serial stdio \
    -d int,cpu_reset \
    -trace "usb*"
```

### QEMU USB è®¾å¤‡é€‰é¡¹

| é€‰é¡¹ | è¯´æ˜ |
|------|------|
| `-usb` | å¯ç”¨ USB æ”¯æŒ |
| `-device usb-kbd` | USB é”®ç›˜ |
| `-device usb-mouse` | USB é¼ æ ‡ |
| `-device usb-tablet` | USB å¹³æ¿ï¼ˆç»å¯¹åæ ‡ï¼‰|
| `-device usb-storage` | USB å­˜å‚¨è®¾å¤‡ |
| `-device usb-hub` | USB Hub |

---

## çƒ­æ’æ‹”æ¶æ„

USB çƒ­æ’æ‹”æ”¯æŒé‡‡ç”¨åŒé‡æ£€æµ‹æœºåˆ¶ç¡®ä¿å¯é æ€§ï¼š

### æ£€æµ‹æœºåˆ¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      çƒ­æ’æ‹”æ£€æµ‹æ¶æ„                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚   IRQ ä¸­æ–­æ£€æµ‹   â”‚     â”‚  å®šæ—¶å™¨è½®è¯¢æ£€æµ‹  â”‚                â”‚
â”‚  â”‚  (å³æ—¶å“åº”)      â”‚     â”‚  (500ms å‘¨æœŸ)   â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚           â”‚                       â”‚                          â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                       â†“                                      â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚           â”‚  uhci_check_port_   â”‚                            â”‚
â”‚           â”‚      changes()      â”‚                            â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚                      â†“                                       â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚           â”‚ æ£€æŸ¥ PORTSC CSC ä½  â”‚                            â”‚
â”‚           â”‚ (Connect Status     â”‚                            â”‚
â”‚           â”‚     Change)         â”‚                            â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚                      â†“                                       â”‚
â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚        â†“                           â†“                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚  â”‚ CCS = 1   â”‚              â”‚ CCS = 0   â”‚                    â”‚
â”‚  â”‚ è®¾å¤‡è¿æ¥  â”‚              â”‚ è®¾å¤‡æ–­å¼€  â”‚                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚        â†“                          â†“                          â”‚
â”‚  usb_handle_port_         usb_handle_port_                   â”‚
â”‚      connect()                disconnect()                   â”‚
â”‚        â†“                          â†“                          â”‚
â”‚  usb_enumerate_           usb_disconnect_                    â”‚
â”‚      device()                 device()                       â”‚
â”‚        â†“                          â†“                          â”‚
â”‚  é©±åŠ¨ probe()              é©±åŠ¨ disconnect()                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ç«¯å£çŠ¶æ€è·Ÿè¸ª

```c
typedef struct uhci_controller {
    // ... å…¶ä»–å­—æ®µ ...
    
    /* çƒ­æ’æ‹”æ”¯æŒ */
    uint16_t port_status[UHCI_NUM_PORTS];      // ä¸Šæ¬¡è®°å½•çš„ç«¯å£çŠ¶æ€
    usb_device_t *port_device[UHCI_NUM_PORTS]; // ç«¯å£ä¸Šçš„è®¾å¤‡æ˜ å°„
} uhci_controller_t;
```

### å…³é”®å‡½æ•°

| å‡½æ•° | å±‚çº§ | è¯´æ˜ |
|------|------|------|
| `uhci_check_port_changes()` | UHCI | æ£€æŸ¥å•ä¸ªæ§åˆ¶å™¨çš„ç«¯å£çŠ¶æ€å˜åŒ– |
| `uhci_poll_port_changes()` | UHCI | æ£€æŸ¥æ‰€æœ‰æ§åˆ¶å™¨çš„ç«¯å£çŠ¶æ€å˜åŒ– |
| `uhci_start_hotplug_monitor()` | UHCI | å¯åŠ¨çƒ­æ’æ‹”ç›‘æ§å®šæ—¶å™¨ |
| `usb_handle_port_connect()` | USB Core | å¤„ç†è®¾å¤‡è¿æ¥äº‹ä»¶ |
| `usb_handle_port_disconnect()` | USB Core | å¤„ç†è®¾å¤‡æ–­å¼€äº‹ä»¶ |
| `usb_disconnect_device()` | USB Core | æ–­å¼€è®¾å¤‡å¹¶é€šçŸ¥é©±åŠ¨ |

---

## æµ‹è¯•ç”¨ä¾‹

### 1. UHCI æ§åˆ¶å™¨æ£€æµ‹æµ‹è¯•

```c
void test_uhci_detection(void) {
    uhci_controller_t *hc = uhci_get_controller(0);
    
    if (hc) {
        kprintf("UHCI controller detected:\n");
        kprintf("  I/O Base: 0x%04x\n", hc->io_base);
        kprintf("  IRQ: %d\n", hc->irq);
        
        // æ£€æŸ¥æ§åˆ¶å™¨æ˜¯å¦è¿è¡Œ
        uint16_t cmd = uhci_read16(hc, UHCI_REG_USBCMD);
        kprintf("  Running: %s\n", (cmd & UHCI_CMD_RS) ? "yes" : "no");
        
        // æ£€æŸ¥ç«¯å£çŠ¶æ€
        for (int i = 0; i < 2; i++) {
            uint16_t status = uhci_get_port_status(hc, i);
            kprintf("  Port %d: 0x%04x (connected: %s)\n",
                    i, status, (status & UHCI_PORT_CCS) ? "yes" : "no");
        }
    } else {
        kprintf("No UHCI controller found\n");
    }
}
```

### 2. USB è®¾å¤‡æšä¸¾æµ‹è¯•

```c
void test_usb_enumeration(void) {
    uhci_controller_t *hc = uhci_get_controller(0);
    if (!hc) return;
    
    for (int port = 0; port < 2; port++) {
        if (!uhci_port_connected(hc, port)) continue;
        
        kprintf("Enumerating device on port %d...\n", port);
        
        // å¤ä½ç«¯å£
        if (uhci_reset_port(hc, port) < 0) {
            kprintf("  Port reset failed\n");
            continue;
        }
        
        // åˆ†é…è®¾å¤‡ç»“æ„
        usb_device_t *dev = usb_alloc_device();
        if (!dev) {
            kprintf("  Failed to allocate device\n");
            continue;
        }
        
        dev->port = port;
        dev->speed = uhci_port_low_speed(hc, port) ? USB_SPEED_LOW : USB_SPEED_FULL;
        dev->hc = hc;
        
        // æšä¸¾è®¾å¤‡
        if (usb_enumerate_device(dev) == 0) {
            kprintf("  Device enumerated:\n");
            kprintf("    Address: %d\n", dev->address);
            kprintf("    Vendor: 0x%04x\n", dev->device_desc.idVendor);
            kprintf("    Product: 0x%04x\n", dev->device_desc.idProduct);
            kprintf("    Class: 0x%02x\n", dev->device_desc.bDeviceClass);
        } else {
            kprintf("  Enumeration failed\n");
            usb_free_device(dev);
        }
    }
}
```

---

## å®ç°é¡ºåº

### é˜¶æ®µ 1: UHCI åŸºç¡€è®¾æ–½
1. [x] å®ç° PCI è®¾å¤‡æ£€æµ‹ï¼ˆæŸ¥æ‰¾ UHCI æ§åˆ¶å™¨ï¼‰
2. [x] å®ç° UHCI å¯„å­˜å™¨è¯»å†™å‡½æ•°
3. [x] å®ç°æ§åˆ¶å™¨å¤ä½å’Œåˆå§‹åŒ–
4. [x] å®ç°å¸§åˆ—è¡¨åˆ†é…å’Œåˆå§‹åŒ–
5. [x] å®ç° TD/QH å†…å­˜æ± ç®¡ç†
6. [x] å®ç°ç«¯å£å¤ä½åŠŸèƒ½
7. [x] å®ç°ä¸­æ–­å¤„ç†æ¡†æ¶

### é˜¶æ®µ 2: USB æ ¸å¿ƒå±‚
8. [x] å®ç° URB åˆ†é…å’Œç®¡ç†
9. [x] å®ç°æ§åˆ¶ä¼ è¾“ï¼ˆSETUP/DATA/STATUSï¼‰
10. [x] å®ç°è®¾å¤‡æè¿°ç¬¦è¯»å–
11. [x] å®ç° SET_ADDRESS å‘½ä»¤
12. [x] å®ç°é…ç½®æè¿°ç¬¦è§£æ
13. [x] å®ç° SET_CONFIGURATION å‘½ä»¤
14. [x] å®ç°å®Œæ•´çš„è®¾å¤‡æšä¸¾æµç¨‹

### é˜¶æ®µ 3: USB è®¾å¤‡é©±åŠ¨
15. [x] å®ç° USB é©±åŠ¨æ³¨å†Œæ¡†æ¶
16. [x] å®ç°çƒ­æ’æ‹”æ”¯æŒï¼ˆç«¯å£çŠ¶æ€æ£€æµ‹ï¼‰
17. [ ] å®ç° HID é©±åŠ¨åŸºç¡€
18. [ ] å®ç° USB é”®ç›˜æ”¯æŒ
19. [ ] æµ‹è¯• USB é”®ç›˜è¾“å…¥
20. [ ] ï¼ˆå¯é€‰ï¼‰å®ç° USB é¼ æ ‡æ”¯æŒ
21. [x] å®ç° Mass Storage é©±åŠ¨

### é˜¶æ®µ 4: ç”¨æˆ·ç©ºé—´æ”¯æŒ
22. [x] å®ç° `/proc/usb` è™šæ‹Ÿæ–‡ä»¶
23. [x] å®ç°ç”¨æˆ·æ€ `lsusb` å‘½ä»¤
24. [x] å®ç°å†…æ ¸ Shell USB è°ƒè¯•å‘½ä»¤

---

## ä¾èµ–å…³ç³»

### å‰ç½®ä¾èµ–

| ä¾èµ–æ¨¡å— | ç”¨é€” |
|----------|------|
| PCI æ€»çº¿é©±åŠ¨ | æ§åˆ¶å™¨æ£€æµ‹å’Œé…ç½® |
| è™šæ‹Ÿå†…å­˜ç®¡ç†ï¼ˆVMMï¼‰ | ç‰©ç†/è™šæ‹Ÿåœ°å€è½¬æ¢ |
| å †å†…å­˜ç®¡ç†ï¼ˆheapï¼‰ | åŠ¨æ€å†…å­˜åˆ†é… |
| IRQ ä¸­æ–­å¤„ç† | ä¸­æ–­é©±åŠ¨ |
| å®šæ—¶å™¨ï¼ˆtimerï¼‰ | å»¶æ—¶å’Œè¶…æ—¶å¤„ç† |

### æä¾›åŠŸèƒ½

| åŠŸèƒ½ | ä½¿ç”¨è€… |
|------|--------|
| USB é”®ç›˜é©±åŠ¨ | ç”¨æˆ·è¾“å…¥ï¼ˆæ›¿ä»£ PS/2ï¼‰|
| USB é¼ æ ‡é©±åŠ¨ | å›¾å½¢ç•Œé¢ï¼ˆæœªæ¥ï¼‰|
| USB å­˜å‚¨é©±åŠ¨ | æ–‡ä»¶ç³»ç»Ÿï¼ˆUç›˜è¯»å†™ï¼‰|

---

## å‚è€ƒèµ„æ–™

### è§„èŒƒæ–‡æ¡£
1. **USB 1.1 è§„èŒƒ**
   - Universal Serial Bus Specification, Revision 1.1 (September 1998)
   - https://www.usb.org/documents

2. **UHCI è§„èŒƒ**
   - Universal Host Controller Interface (UHCI) Design Guide
   - Intel, Revision 1.1 (March 1996)
   - https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/usb-uhci11d.pdf

### å¼€æºå®ç°å‚è€ƒ
3. **Linux kernel**
   - `drivers/usb/host/uhci-hcd.c` - UHCI ä¸»æœºæ§åˆ¶å™¨é©±åŠ¨
   - `drivers/usb/core/` - USB æ ¸å¿ƒå±‚
   - `drivers/hid/usbhid/` - USB HID é©±åŠ¨

4. **OSDev Wiki**
   - [USB](https://wiki.osdev.org/USB)
   - [UHCI](https://wiki.osdev.org/Universal_Host_Controller_Interface)
   - [USB Human Interface Devices](https://wiki.osdev.org/USB_Human_Interface_Devices)

### è°ƒè¯•å·¥å…·
7. **QEMU USB è°ƒè¯•**
   - ä½¿ç”¨ `-trace "usb*"` å¯ç”¨ USB è·Ÿè¸ª
   - ä½¿ç”¨ `-device usb-host` ç›´é€šä¸»æœº USB è®¾å¤‡

8. **USB åè®®åˆ†æ**
   - Wireshark USB æ•è·
   - USBPcapï¼ˆWindowsï¼‰

---

## é™„å½•ï¼šå¸¸è§é—®é¢˜

### Q1: ä¸ºä»€ä¹ˆé€‰æ‹© UHCI è€Œä¸æ˜¯ OHCIï¼Ÿ

A: ThinkPad T41 ä½¿ç”¨ Intel ICH4 èŠ¯ç‰‡ç»„ï¼Œå†…ç½® UHCI æ§åˆ¶å™¨ã€‚UHCI ç›¸å¯¹ç®€å•ï¼Œé€‚åˆå­¦ä¹ ã€‚å¦‚æœéœ€è¦æ”¯æŒæ›´å¤šç¡¬ä»¶ï¼Œå¯ä»¥åç»­æ·»åŠ  OHCI æ”¯æŒã€‚

### Q2: USB 2.0/3.0 æ”¯æŒï¼Ÿ

A: USB 2.0 ä½¿ç”¨ EHCI æ§åˆ¶å™¨ï¼ŒUSB 3.0 ä½¿ç”¨ xHCI æ§åˆ¶å™¨ã€‚è¿™äº›æ˜¯ç‹¬ç«‹çš„é©±åŠ¨ï¼Œå¯ä»¥åœ¨å®Œæˆ USB 1.1 åä½œä¸ºæ‰©å±•å®ç°ã€‚QEMU é»˜è®¤ä½¿ç”¨ UHCIï¼ˆUSB 1.1ï¼‰ã€‚

### Q3: å¦‚ä½•å¤„ç† USB çƒ­æ’æ‹”ï¼Ÿ

A: CastorOS å·²å®ç° USB çƒ­æ’æ‹”æ”¯æŒï¼Œé‡‡ç”¨åŒé‡æ£€æµ‹æœºåˆ¶ï¼š

1. **ä¸­æ–­æ£€æµ‹**ï¼šUHCI ä¸­æ–­å¤„ç†ç¨‹åºæ£€æŸ¥ PORTSC çš„ CSCï¼ˆConnect Status Changeï¼‰ä½
2. **å®šæ—¶è½®è¯¢**ï¼šæ¯ 500ms æ£€æŸ¥ä¸€æ¬¡ç«¯å£çŠ¶æ€ï¼ˆä½œä¸ºå¤‡ä»½æœºåˆ¶ï¼‰

çƒ­æ’æ‹”æµç¨‹ï¼š
- **è®¾å¤‡è¿æ¥**ï¼šæ£€æµ‹åˆ° CSC ä¸” CCS=1 â†’ ç­‰å¾…ç¨³å®š â†’ æšä¸¾è®¾å¤‡ â†’ åŠ è½½é©±åŠ¨
- **è®¾å¤‡æ–­å¼€**ï¼šæ£€æµ‹åˆ° CSC ä¸” CCS=0 â†’ è°ƒç”¨é©±åŠ¨ disconnect â†’ é‡Šæ”¾èµ„æº

ç›¸å…³å‡½æ•°ï¼š
- `uhci_check_port_changes()` - æ£€æŸ¥ç«¯å£çŠ¶æ€å˜åŒ–
- `uhci_start_hotplug_monitor()` - å¯åŠ¨çƒ­æ’æ‹”ç›‘æ§å®šæ—¶å™¨
- `usb_handle_port_connect()` / `usb_handle_port_disconnect()` - å¤„ç†è¿æ¥/æ–­å¼€äº‹ä»¶

### Q4: ä¸ºä»€ä¹ˆéœ€è¦å¸§åˆ—è¡¨ï¼Ÿ

A: UHCI ä½¿ç”¨å¸§åˆ—è¡¨è¿›è¡Œæ—¶é—´è°ƒåº¦ã€‚æ¯ 1ms ç¡¬ä»¶è‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªå¸§ï¼Œè¿™ä¿è¯äº†ä¸­æ–­ä¼ è¾“å’Œç­‰æ—¶ä¼ è¾“çš„å‘¨æœŸæ€§ã€‚æ§åˆ¶ä¼ è¾“å’Œæ‰¹é‡ä¼ è¾“åˆ™é€šè¿‡ QH é“¾æ¥åˆ°å¸§åˆ—è¡¨æ¡ç›®ã€‚

### Q5: TD å’Œ QH çš„åŒºåˆ«ï¼Ÿ

A: TDï¼ˆTransfer Descriptorï¼‰æè¿°å•ä¸ª USB æ•°æ®åŒ…ä¼ è¾“ã€‚QHï¼ˆQueue Headï¼‰ç”¨äºç»„ç»‡å¤šä¸ª TDï¼Œæ”¯æŒé˜Ÿåˆ—åŒ–ä¼ è¾“ã€‚æ§åˆ¶ä¼ è¾“å’Œæ‰¹é‡ä¼ è¾“é€šå¸¸ä½¿ç”¨ QH+TD ç»„åˆã€‚


