# 阶段 8: FAT32 文件系统支持

## 概述

本阶段实现了 FAT32 文件系统支持，包括块设备抽象层（blockdev）和分区抽象层（partition）。这使得 CastorOS 能够访问存储在块设备（如硬盘）上的 FAT32 文件系统。

**📝 设计理念**：

本文档采用了**分层存储架构**，具有以下特点：

✅ **块设备抽象层（blockdev）**
   - 统一的块设备访问接口
   - 支持按扇区读写
   - 设备大小和块大小查询

✅ **分区抽象层（partition）**
   - 支持 MBR 与 GPT 分区表解析
   - 将分区暴露为独立块设备
   - 自动过滤保护 MBR、空分区等无效项目

✅ **文件系统引导层（fs_bootstrap）**
   - 启动阶段统一探测块设备与分区
   - 优先使用 FAT32 作为根文件系统，失败时回退 RAMFS
   - 虚拟文件系统（devfs）挂载到 `/dev`，容错启动

✅ **FAT32 文件系统**
   - 完整的 FAT32 支持
   - 文件读写
   - 目录遍历
   - 8.3 格式文件名支持

这种架构为未来支持其他文件系统（如 ext2）和其他分区表格式（如 GPT）奠定了良好基础。

---

## 目标

- ✅ 实现块设备抽象层（blockdev）
- ✅ 实现分区抽象层（partition，支持 MBR 与 GPT）
- ✅ 实现 FAT32 文件系统
- ✅ 支持文件读写和目录遍历
- ✅ 集成到 VFS 层，并通过 fs_bootstrap 自动挂载根文件系统

---

## 技术背景

### 块设备抽象

**块设备（Block Device）** 是按固定大小的块（通常是 512 字节的扇区）进行读写的存储设备。

**块设备的特性**：
- 数据以扇区为单位访问
- 支持随机访问
- 通常用于存储设备（硬盘、SSD、USB 等）

**块设备抽象层的优势**：
```
文件系统只需要知道：
  blockdev_read(dev, sector, count, buffer)
  
而不需要关心：
  - 设备是 IDE、SATA 还是其他接口？
  - 设备是物理硬盘还是虚拟设备？
  - 设备是否被分区？
```

### MBR 分区表

**MBR（Master Boot Record）** 是传统的分区表格式，位于磁盘的第一个扇区。

**MBR 结构**：
```
扇区 0 (512 字节):
  - 引导代码 (446 字节)
  - 分区表 (4 个分区项，每个 16 字节)
  - 签名 (0xAA55, 2 字节)
```

**分区表项结构**（16 字节）：
- 引导标志（1 字节）
- 起始 CHS（3 字节）
- 分区类型（1 字节）
- 结束 CHS（3 字节）
- 起始 LBA（4 字节，小端序）
- 扇区数（4 字节，小端序）

### FAT32 文件系统

**FAT32（File Allocation Table 32）** 是微软开发的文件系统，广泛用于 USB 驱动器和 SD 卡。

**FAT32 结构**：
```
磁盘布局：
  - 引导扇区（BPB - BIOS Parameter Block）
  - 保留扇区
  - FAT 表（通常有 2 个副本）
  - 数据区（文件和目录）
```

**FAT32 关键概念**：
1. **簇（Cluster）**：文件系统分配的最小单位，由多个扇区组成
2. **FAT 表**：记录每个簇的链接关系，形成文件链
3. **目录项**：32 字节，包含文件名、属性、起始簇号、文件大小等

---

## 实现设计

### 1. 块设备抽象层

#### 核心数据结构

**块设备结构**：

```c
typedef struct blockdev {
    char name[64];                      // 设备名称
    void *private_data;                 // 设备私有数据
    uint32_t block_size;                // 块大小（字节）
    uint32_t total_sectors;             // 总扇区数
    
    // 操作函数
    blockdev_read_t read;
    blockdev_write_t write;
    blockdev_get_size_t get_size;
    blockdev_get_block_size_t get_block_size;
} blockdev_t;
```

**核心函数**：

```c
// 读取块设备
int blockdev_read(blockdev_t *dev, uint32_t sector, uint32_t count, uint8_t *buffer);

// 写入块设备
int blockdev_write(blockdev_t *dev, uint32_t sector, uint32_t count, const uint8_t *buffer);

// 获取设备大小（扇区数）
uint32_t blockdev_get_size(blockdev_t *dev);

// 获取块大小（字节）
uint32_t blockdev_get_block_size(blockdev_t *dev);
```

### 2. 分区抽象层

#### 核心数据结构

**分区信息**：

```c
typedef struct partition {
    uint8_t index;                 // 分区索引
    uint64_t start_lba;            // 起始 LBA
    uint64_t sector_count;         // 扇区数
    uint8_t type;                  // MBR 分区类型
    bool active;                   // 是否为活动分区
    bool is_gpt;                   // 是否来自 GPT
    gpt_guid_t type_guid;          // GPT 分区 GUID
    blockdev_t *parent_dev;        // 父块设备
} partition_t;
```

**核心函数**：

```c
// 自动解析分区表（优先 GPT，回退 MBR）
int partition_parse(blockdev_t *dev, partition_t *partitions, uint32_t *count);

// 创建分区块设备
blockdev_t *partition_create_blockdev(partition_t *part);

// 释放分区块设备
void partition_destroy_blockdev(blockdev_t *dev);
```

### 3. FAT32 文件系统

**核心函数**：

```c
// 初始化 FAT32 文件系统
fs_node_t *fat32_init(blockdev_t *dev);

// 探测是否为 FAT32 文件系统
bool fat32_probe(blockdev_t *dev);
```

---

## 实现步骤

1. **块设备抽象层** (`blockdev.h/c`)：统一的块设备访问接口
2. **分区抽象层** (`partition.h/c`)：MBR/GPT 分区表解析
3. **FAT32 文件系统** (`fat32.h/c`)：FAT32 实现
4. **文件系统引导层** (`fs_bootstrap.h/c`)：启动时自动挂载根文件系统

---

## 使用示例

启动时系统自动探测分区并挂载 FAT32 作为根文件系统，用户可通过 VFS 接口访问文件：

```c
// 读取文件
fs_node_t *file = vfs_path_to_node("/readme.txt");
vfs_read(file, 0, 1024, buffer);

// 创建目录
vfs_mkdir("/mydir", FS_PERM_READ | FS_PERM_WRITE | FS_PERM_EXEC);

// 创建文件
fs_node_t *dir = vfs_path_to_node("/mydir");
dir->create(dir, "config.txt");

// 遍历目录
uint32_t index = 0;
struct dirent *entry;
while ((entry = vfs_readdir(dir, index++)) != NULL) {
    printf("Found: %s\n", entry->d_name);
}
```

---

## 性能优化

### FSInfo 扇区优化

**问题**：簇分配需要线性扫描 FAT 表，对于大磁盘可能需要扫描数千个簇。

**解决方案**：使用 FAT32 标准的 FSInfo 扇区记录下一个空闲簇号。

**优化效果**：
- 第一次分配：9384 倍提升（从扫描 9384 个簇 → 1 个簇）
- 创建目录：从几秒 → 毫秒级

**实现**：
1. 启动时读取 FSInfo 扇区，获取 `next_free_cluster`
2. 分配簇时从 `next_free_cluster` 开始扫描
3. 分配成功后更新 `fs->next_free_cluster`
4. 如果没找到空闲簇，回到簇 2 重新扫描

---

## 启动策略

CastorOS 采用**优先级启动策略**：

1. 尝试初始化 FAT32 作为根文件系统
2. 失败时回退到 RAMFS
3. 创建虚拟挂载点 `/dev` 并挂载 devfs

**容错机制**：

| 步骤 | 失败处理 |
|------|---------|
| FAT32 初始化 | 回退到 RAMFS |
| `/dev` 创建 | 警告继续 |
| devfs 挂载 | 错误继续 |

这种设计确保系统总能启动，即使遇到存储设备问题。

---

## 实现细节

### FAT32 文件读取

1. 定位起始簇号
2. 根据文件偏移计算当前簇和簇内偏移
3. 通过 FAT 表遍历文件的所有簇
4. 将簇数据复制到缓冲区

### FAT32 目录遍历

1. 读取目录起始簇
2. 遍历簇中的所有目录项（每个 32 字节）
3. 跳过已删除、长文件名、卷标等项
4. 将 8.3 格式文件名转换为普通格式

### 分区访问

- 将分区内的扇区号转换为父设备的扇区号
- 确保访问不超出分区范围
- 对上层文件系统透明

---

## 限制和未来改进

### 当前限制

1. 仅支持删除普通文件和空目录
2. 不支持长文件名（LFN），只处理 8.3 格式
3. 只使用第一个 FAT 表，不检查备份
4. FSInfo 不可用时回退到线性扫描

### 未来改进

1. 完善删除流程（unlink/rmdir）
2. 长文件名支持（LFN）
3. FAT 表缓存优化
4. FSInfo 写回机制
5. 其他文件系统支持（ext2、NTFS）

---

## 文件清单

### 新增文件

- `src/include/fs/blockdev.h` - 块设备抽象层头文件
- `src/fs/blockdev.c` - 块设备抽象层实现
- `src/include/fs/partition.h` - 分区抽象层头文件（支持 GPT）
- `src/fs/partition.c` - 分区抽象层实现
- `src/include/fs/fat32.h` - FAT32 文件系统头文件
- `src/fs/fat32.c` - FAT32 文件系统实现
- `src/include/kernel/fs_bootstrap.h` - 文件系统引导层接口
- `src/kernel/fs_bootstrap.c` - 文件系统启动与根挂载逻辑
