# 阶段 3: 内存管理

## 概述

实现物理内存管理（PMM）、虚拟内存管理（VMM）和堆内存分配器（Heap）。

## 目标

- ✅ 实现物理内存管理器（PMM - 位图方式）
- ✅ 实现虚拟内存管理器（VMM - 页表管理）
- ✅ 实现堆内存分配器（kmalloc/kfree）
- ✅ 完善页错误处理

## 技术要点

**物理内存管理（PMM）**：使用位图管理 4KB 页帧，每位表示一个页帧的状态（0=空闲，1=占用）。

**虚拟内存管理（VMM）**：管理页目录和页表，实现虚拟地址到物理地址的映射。

**堆分配器（Heap）**：使用首次适配算法和链表管理动态内存分配。

**内存布局**：
```
0xFFFFFFFF  ┌─────────────────┐
            │ Reserved        │ ← 预留空间
0x81000000  ├─────────────────┤
            │ Kernel Heap     │ ← kmalloc 区域
heap_start  ├─────────────────┤
            │ Kernel Code     │ ← 内核代码/数据
0x80100000  ├─────────────────┤
0x80000000  │ High Kernel Base│ ← 高半核基址
            │ User Space      │ ← 用户空间
0x00000000  └─────────────────┘
```

---

## 实现步骤

### 步骤 0: 更新 types.h

**文件**: `src/include/types.h`

```c
#define PAGE_SIZE           4096
#define PAGE_SHIFT          12
#define PAGE_MASK           0xFFFFF000
#define KERNEL_VIRTUAL_BASE 0x80000000

#define VIRT_TO_PHYS(addr)  ((uint32_t)(addr) - KERNEL_VIRTUAL_BASE)
#define PHYS_TO_VIRT(addr)  ((uint32_t)(addr) + KERNEL_VIRTUAL_BASE)
#define PAGE_ALIGN_DOWN(addr) ((addr) & PAGE_MASK)
#define PAGE_ALIGN_UP(addr)   (((addr) + PAGE_SIZE - 1) & PAGE_MASK)
```

---

### 步骤 1: 实现物理内存管理器（PMM）

**实现方法**：
- **位图管理**：使用 `uint32_t` 数组作为位图，每位代表一个 4KB 页帧（0=空闲，1=占用）
- **初始化流程**：解析 Multiboot 内存映射 → 计算总页帧数 → 将位图置于内核末尾 → 初始化所有位为 1 → 遍历可用内存区域清零对应位
- **分配策略**：线性扫描位图查找第一个空闲页帧（首次适应），分配后清零页面内容
- **限制处理**：高半核映射限制物理内存为 2GB（0x80000000），超出部分自动截断并警告

**文件**: `src/include/mm/pmm.h`
**文件**: `src/mm/pmm.c`

### 步骤 2: 实现虚拟内存管理器（VMM）

**实现方法**：
- **二级页表结构**：1024 项页目录（每项指向页表）+ 1024 项页表（每项映射 4KB 页面），支持 4GB 虚拟地址空间
- **按需分配**：映射页面时若页表不存在则动态创建（调用 `pmm_alloc_frame`），页表项包含物理地址和权限标志
- **地址拆分**：虚拟地址高 10 位为页目录索引，中间 10 位为页表索引，低 12 位为页内偏移
- **TLB 刷新**：单页刷新用 `invlpg` 指令，全局刷新重新加载 CR3 寄存器
- **进程隔离**：内核空间（0x80000000-0xFFFFFFFF）在所有进程间共享，用户空间独立管理

**文件**: `src/include/mm/vmm.h`
**文件**: `src/mm/vmm.c`

### 步骤 3: 实现堆内存分配器

**实现方法**：
- **双向链表 + 首次适应**：每个内存块包含头信息（大小、状态、前后指针、魔数），遍历链表找第一个足够大的空闲块
- **动态扩展**：若无合适空闲块，调用 `expand()` 分配物理页并通过 VMM 映射到堆虚拟地址空间
- **碎片优化**：释放时调用 `coalesce()` 向前/向后合并相邻空闲块，分配时调用 `split()` 分裂过大块
- **安全检查**：使用魔数（0xDEADBEEF）验证块头有效性，分配大小对齐到 4 字节边界
- **扩展机制**：初始分配 1 页（4KB），不足时按需扩展，最大不超过 `heap_max`

**文件**: `src/include/mm/heap.h`
**文件**: `src/mm/heap.c`

### 步骤 4: 页错误处理

**更新**: `src/kernel/isr.c` -> page_fault_handler

### 步骤 5: 增加 kernel panic 实现

**文件**: `src/include/kernel/panic.h`
**文件**: `src/kernel/panic.c`

### 步骤 6: 更新 kernel_main

**文件**: `src/kernel/kernel.c`

```c
// ============================================================================
// kernel.c - 内核主函数
// ============================================================================

#include <drivers/vga.h>
#include <drivers/serial.h>
#include <kernel/multiboot.h>
#include <kernel/version.h>

#include <lib/kprintf.h>
#include <lib/klog.h>

#include <kernel/gdt.h>
#include <kernel/idt.h>
#include <kernel/irq.h>
#include <kernel/isr.h>

#include <mm/pmm.h>
#include <mm/vmm.h>
#include <mm/heap.h>

#include <tests/test_runner.h>

// 内核主函数
void kernel_main(multiboot_info_t* mbi) {
    // ========================================================================
    // 阶段 0: 早期初始化
    // ========================================================================    
    vga_init(); // 初始化 VGA
    serial_init(); // 初始化串口

    // ========================================================================
    // 启动信息
    // ========================================================================
    kprintf("Welcome to CastorOS!\n");
    kprintf("Version v%s\n", KERNEL_VERSION);
    kprintf("Compiled on: %s %s\n", __DATE__, __TIME__);

    // ========================================================================
    // 阶段 1: CPU 基础架构（CPU Architecture）
    // ========================================================================
    LOG_INFO_MSG("[Stage 1] Initializing CPU architecture...\n");
    
    // 1.1 初始化 GDT（Global Descriptor Table）
    gdt_init();
    LOG_DEBUG_MSG("  [1.1] GDT initialized\n");
    
    // ========================================================================
    // 阶段 2: 中断系统（Interrupt System）
    // ========================================================================
    LOG_INFO_MSG("[Stage 2] Initializing interrupt system...\n");
    
    // 2.1 初始化 IDT（Interrupt Descriptor Table）
    idt_init();
    LOG_DEBUG_MSG("  [2.1] IDT initialized\n");
    
    // 2.2 初始化 ISR（Interrupt Service Routines - 异常处理）
    isr_init();
    LOG_DEBUG_MSG("  [2.2] ISR initialized (Exception handlers)\n");
    
    // 2.3 初始化 IRQ（Hardware Interrupt Requests - 硬件中断）
    irq_init();
    LOG_DEBUG_MSG("  [2.3] IRQ initialized (Hardware interrupts)\n");

    // ========================================================================
    // 阶段 3: 内存管理（Memory Management）
    // ========================================================================   
    LOG_INFO_MSG("[Stage 3] Initializing memory management...\n");
    
    // 3.0 显示 Multiboot 内存信息
    if (mbi && (mbi->flags & 0x01)) {
        kprintf("  Memory detected: %u KB (lower) + %u KB (upper) = %u MB\n",
                mbi->mem_lower, mbi->mem_upper,
                (mbi->mem_lower + mbi->mem_upper) / 1024);
    } else {
        LOG_WARN_MSG("  Warning: Memory info not available from bootloader\n");
    }
    
    // 3.1 初始化 PMM（Physical Memory Manager - 物理内存管理）阶段1
    //     解析内存映射，记录所有可用区域
    pmm_init(mbi);
    LOG_DEBUG_MSG("  [3.1] PMM phase 1 initialized\n");
    
    // 3.2 初始化 VMM（Virtual Memory Manager - 虚拟内存管理）
    vmm_init();
    LOG_DEBUG_MSG("  [3.2] VMM initialized\n");
    
    // 3.5 初始化 Heap（堆内存分配器）
    // 堆起始地址：PMM 位图之后（避免与位图重叠）
    uint32_t heap_start = pmm_get_bitmap_end();
    
    // 确保堆不会覆盖 multiboot 模块
    if (mbi->flags & MULTIBOOT_INFO_MODS && mbi->mods_count > 0) {
        multiboot_module_t *modules = (multiboot_module_t *)PHYS_TO_VIRT(mbi->mods_addr);
        
        // 检查模块列表结束位置
        uint32_t mods_list_end = PHYS_TO_VIRT(mbi->mods_addr + sizeof(multiboot_module_t) * mbi->mods_count);
        if (mods_list_end > heap_start) {
            heap_start = mods_list_end;
        }
        
        // 检查每个模块的结束位置
        for (uint32_t i = 0; i < mbi->mods_count; i++) {
            uint32_t mod_end_virt = PHYS_TO_VIRT(modules[i].mod_end);
            if (mod_end_virt > heap_start) {
                heap_start = mod_end_virt;
            }
        }
        
        heap_start = PAGE_ALIGN_UP(heap_start);
        LOG_DEBUG_MSG("  Heap start adjusted for multiboot modules: %x\n", heap_start);
    }
    
    heap_init(heap_start, 32 * 1024 * 1024);  // 32MB 堆
    heap_print_info();
    LOG_DEBUG_MSG("  [3.3] Heap initialized\n");

    // ========================================================================
    // 单元测试
    // ========================================================================
    LOG_INFO_MSG("Running test suite...\n");
    run_all_tests();
    kprintf("\n");
    
    // 进入空闲循环
    while (1) {
        __asm__ volatile ("hlt");
    }
}
```
