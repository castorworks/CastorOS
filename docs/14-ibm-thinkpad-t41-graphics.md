# é˜¶æ®µ 14: IBM ThinkPad T41 æ˜¾å¡é©±åŠ¨

## æ¦‚è¿°

æœ¬é˜¶æ®µå°†ä¸º IBM ThinkPad T41 ç¬”è®°æœ¬ç”µè„‘å®ç°å›¾å½¢æ˜¾ç¤ºæ”¯æŒã€‚T41 ç³»åˆ—é…å¤‡ ATI Mobility Radeon 7500/9000 æ˜¾å¡ï¼Œæ”¯æŒä¸¤ç§å±å¹•é…ç½®ï¼š

- **XGA å‹å·**ï¼š1024Ã—768 åˆ†è¾¨ç‡
- **SXGA+ å‹å·**ï¼š1400Ã—1050 åˆ†è¾¨ç‡

ç”±äºå½“å‰å†…æ ¸ä»…æ”¯æŒ VGA æ–‡æœ¬æ¨¡å¼ï¼ˆ80Ã—25ï¼‰ï¼Œæœ¬é˜¶æ®µå°†å®ç°ä»æ–‡æœ¬æ¨¡å¼åˆ°å›¾å½¢æ¨¡å¼çš„å®Œæ•´å‡çº§ï¼Œå¹¶**è‡ªåŠ¨é€‚é…ä¸åŒåˆ†è¾¨ç‡çš„å±å¹•**ã€‚

**ğŸ“ è®¾è®¡ç†å¿µ**ï¼š

æœ¬é˜¶æ®µé‡‡ç”¨**æ¸è¿›å¼å›¾å½¢æ”¯æŒ**æ¶æ„ï¼š

âœ… **PCI æ€»çº¿é©±åŠ¨**
   - å®ç° PCI é…ç½®ç©ºé—´è®¿é—®
   - è®¾å¤‡æšä¸¾ä¸èµ„æºåˆ†é…
   - ä¸ºæ˜¾å¡å’Œå…¶ä»– PCI è®¾å¤‡æä¾›ç»Ÿä¸€è®¿é—®æ¥å£

âœ… **VESA VBE å¸§ç¼“å†²**
   - é€šè¿‡ VESA BIOS Extensions è®¾ç½®å›¾å½¢æ¨¡å¼
   - çº¿æ€§å¸§ç¼“å†²ï¼ˆLinear Framebufferï¼‰æ”¯æŒ
   - ç¡¬ä»¶æ— å…³çš„åŸºç¡€å›¾å½¢æ¨¡å¼

âœ… **ATI Radeon åŸºç¡€é©±åŠ¨**ï¼ˆå¯é€‰ï¼‰
   - ç›´æ¥è®¿é—®æ˜¾å¡å¯„å­˜å™¨
   - æ¨¡å¼è®¾ç½®ï¼ˆModesettingï¼‰
   - 2D åŠ é€Ÿæ“ä½œ

âœ… **å¸§ç¼“å†²æŠ½è±¡å±‚**
   - ç»Ÿä¸€çš„å›¾å½¢æ“ä½œæ¥å£
   - åƒç´ ç»˜åˆ¶ã€çŸ©å½¢å¡«å……ã€ä½å›¾ä¼ è¾“
   - ä¸ºæœªæ¥ GUI ç³»ç»Ÿå¥ å®šåŸºç¡€

---

## ç›®æ ‡

- [ ] å®ç° PCI æ€»çº¿æšä¸¾å’Œé…ç½®ç©ºé—´è®¿é—®
- [ ] å®ç° VESA VBE å›¾å½¢æ¨¡å¼è®¾ç½®
- [ ] å®ç°å¸§ç¼“å†²é©±åŠ¨æŠ½è±¡å±‚
- [ ] å®ç°åŸºç¡€å›¾å½¢æ“ä½œï¼ˆåƒç´ ã€çº¿æ¡ã€çŸ©å½¢ã€å­—ç¬¦æ¸²æŸ“ï¼‰
- [ ] æ”¯æŒå¤šåˆ†è¾¨ç‡ï¼š1024Ã—768 å’Œ 1400Ã—1050ï¼ˆ32bppï¼‰
- [ ] å®ç° EDID è¯»å–ï¼Œè‡ªåŠ¨æ£€æµ‹æ˜¾ç¤ºå™¨åŸç”Ÿåˆ†è¾¨ç‡
- [ ] ï¼ˆå¯é€‰ï¼‰ATI Radeon 7500/9000 åŸç”Ÿé©±åŠ¨

---

## æŠ€æœ¯èƒŒæ™¯

### IBM ThinkPad T41 æ˜¾å¡è§„æ ¼

**ATI Mobility Radeon 7500** è§„æ ¼ï¼š
- GPU æ¶æ„ï¼šRV200ï¼ˆR200 ç³»åˆ—ç§»åŠ¨ç‰ˆï¼‰
- æ˜¾å­˜ï¼š16MB/32MB DDR SDRAM
- æ ¸å¿ƒé¢‘ç‡ï¼š230-290 MHz
- æ˜¾å­˜é¢‘ç‡ï¼š183-230 MHz
- æ¥å£ï¼šAGP 4x
- æœ€å¤§åˆ†è¾¨ç‡ï¼š2048Ã—1536ï¼ˆå¤–æ¥ï¼‰/ 1400Ã—1050ï¼ˆå†…ç½® LCDï¼‰

**ATI Mobility Radeon 9000** è§„æ ¼ï¼ˆéƒ¨åˆ† T41 å‹å·ï¼‰ï¼š
- GPU æ¶æ„ï¼šRV250
- æ˜¾å­˜ï¼š32MB/64MB DDR
- æ ¸å¿ƒé¢‘ç‡ï¼š250 MHz
- DirectX 8.1 æ”¯æŒ

**T41 å†…ç½®æ˜¾ç¤ºå±**ï¼š
- å°ºå¯¸ï¼š14.1 è‹±å¯¸
- åˆ†è¾¨ç‡ï¼š1024Ã—768ï¼ˆXGAï¼‰æˆ– 1400Ã—1050ï¼ˆSXGA+ï¼‰
- ç±»å‹ï¼šTFT LCD

### PCI æ€»çº¿åŸºç¡€

**PCIï¼ˆPeripheral Component Interconnectï¼‰** æ˜¯ x86 å¹³å°çš„æ ‡å‡†å¤–è®¾æ€»çº¿ã€‚

**PCI é…ç½®ç©ºé—´**ï¼š
- æ¯ä¸ª PCI è®¾å¤‡æœ‰ 256 å­—èŠ‚çš„é…ç½®ç©ºé—´
- é€šè¿‡ I/O ç«¯å£ 0xCF8ï¼ˆåœ°å€ï¼‰å’Œ 0xCFCï¼ˆæ•°æ®ï¼‰è®¿é—®
- åŒ…å«è®¾å¤‡ IDã€å‚å•† IDã€BARï¼ˆåŸºåœ°å€å¯„å­˜å™¨ï¼‰ç­‰ä¿¡æ¯

**é…ç½®ç©ºé—´åœ°å€æ ¼å¼**ï¼ˆç«¯å£ 0xCF8ï¼‰ï¼š
```
31  30-24   23-16    15-11      10-8       7-2       1-0
+---+-------+--------+----------+----------+---------+---+
| E | Rsvd  |  Bus   | Device   | Function | Register| 0 |
+---+-------+--------+----------+----------+---------+---+
  1    7        8         5          3          6       2

E = Enable Bit (å¿…é¡»ä¸º 1)
```

**å¸¸ç”¨é…ç½®ç©ºé—´å¯„å­˜å™¨**ï¼š
```
åç§»é‡  å¤§å°  åç§°
0x00    2    Vendor ID (å‚å•† ID)
0x02    2    Device ID (è®¾å¤‡ ID)
0x04    2    Command (å‘½ä»¤å¯„å­˜å™¨)
0x06    2    Status (çŠ¶æ€å¯„å­˜å™¨)
0x08    1    Revision ID
0x09    3    Class Code (è®¾å¤‡ç±»å‹)
0x0C    1    Cache Line Size
0x0D    1    Latency Timer
0x0E    1    Header Type
0x10-0x24    BAR 0-5 (åŸºåœ°å€å¯„å­˜å™¨)
0x2C    2    Subsystem Vendor ID
0x2E    2    Subsystem ID
0x3C    1    Interrupt Line
0x3D    1    Interrupt Pin
```

**ATI æ˜¾å¡è¯†åˆ«**ï¼š
- Vendor IDï¼š0x1002ï¼ˆATI Technologiesï¼‰
- Radeon 7500 Device IDï¼š0x4C57ï¼ˆRV200 [Mobility Radeon 7500]ï¼‰
- Radeon 9000 Device IDï¼š0x4C66ï¼ˆRV250 [Mobility Radeon 9000]ï¼‰

### VESA VBEï¼ˆVideo BIOS Extensionsï¼‰

**VBE** æä¾›äº†ç¡¬ä»¶æ— å…³çš„å›¾å½¢æ¨¡å¼è®¾ç½®æ–¹æ³•ã€‚

**VBE ç‰ˆæœ¬**ï¼š
- VBE 1.xï¼šåŸºç¡€å›¾å½¢æ¨¡å¼
- VBE 2.0ï¼šçº¿æ€§å¸§ç¼“å†²æ”¯æŒ
- VBE 3.0ï¼šåˆ·æ–°ç‡æ§åˆ¶

**VBE è°ƒç”¨æ–¹å¼**ï¼š
ç”±äº VBE é€šè¿‡ BIOS ä¸­æ–­ï¼ˆINT 10hï¼‰è°ƒç”¨ï¼Œåœ¨ä¿æŠ¤æ¨¡å¼ä¸‹éœ€è¦ï¼š
1. åˆ‡æ¢åˆ°å®æ¨¡å¼æˆ– V86 æ¨¡å¼
2. æˆ–è€…åœ¨å¼•å¯¼é˜¶æ®µï¼ˆGRUBï¼‰é¢„å…ˆè®¾ç½®å›¾å½¢æ¨¡å¼
3. æˆ–è€…é€šè¿‡ Multiboot2 çš„ framebuffer tag è·å–å¸§ç¼“å†²ä¿¡æ¯

**VBE æ¨¡å¼ä¿¡æ¯ç»“æ„**ï¼š
```c
typedef struct vbe_mode_info {
    uint16_t attributes;         // æ¨¡å¼å±æ€§
    uint8_t  window_a;           // çª—å£ A å±æ€§
    uint8_t  window_b;           // çª—å£ B å±æ€§
    uint16_t granularity;        // çª—å£ç²’åº¦
    uint16_t window_size;        // çª—å£å¤§å°
    uint16_t segment_a;          // çª—å£ A æ®µåœ°å€
    uint16_t segment_b;          // çª—å£ B æ®µåœ°å€
    uint32_t win_func_ptr;       // çª—å£å‡½æ•°æŒ‡é’ˆ
    uint16_t pitch;              // æ¯è¡Œå­—èŠ‚æ•°
    uint16_t width;              // æ°´å¹³åˆ†è¾¨ç‡
    uint16_t height;             // å‚ç›´åˆ†è¾¨ç‡
    uint8_t  w_char;             // å­—ç¬¦å•å…ƒå®½åº¦
    uint8_t  y_char;             // å­—ç¬¦å•å…ƒé«˜åº¦
    uint8_t  planes;             // å†…å­˜å¹³é¢æ•°
    uint8_t  bpp;                // æ¯åƒç´ ä½æ•°
    uint8_t  banks;              // å†…å­˜ bank æ•°
    uint8_t  memory_model;       // å†…å­˜æ¨¡å‹
    uint8_t  bank_size;          // bank å¤§å°
    uint8_t  image_pages;        // å›¾åƒé¡µæ•°
    uint8_t  reserved0;
    // ç›´æ¥é¢œè‰²å­—æ®µ
    uint8_t  red_mask;           // çº¢è‰²æ©ç å¤§å°
    uint8_t  red_position;       // çº¢è‰²ä½ä½ç½®
    uint8_t  green_mask;         // ç»¿è‰²æ©ç å¤§å°
    uint8_t  green_position;     // ç»¿è‰²ä½ä½ç½®
    uint8_t  blue_mask;          // è“è‰²æ©ç å¤§å°
    uint8_t  blue_position;      // è“è‰²ä½ä½ç½®
    uint8_t  reserved_mask;      // ä¿ç•™æ©ç å¤§å°
    uint8_t  reserved_position;  // ä¿ç•™ä½ä½ç½®
    uint8_t  direct_color_attributes;
    uint32_t framebuffer;        // å¸§ç¼“å†²ç‰©ç†åœ°å€
    uint32_t off_screen_mem_off; // ç¦»å±å†…å­˜åç§»
    uint16_t off_screen_mem_size;// ç¦»å±å†…å­˜å¤§å°
    // VBE 3.0 å­—æ®µ...
} __attribute__((packed)) vbe_mode_info_t;
```

### å¸§ç¼“å†²ï¼ˆFramebufferï¼‰æ¦‚å¿µ

**å¸§ç¼“å†²** æ˜¯æ˜¾å­˜ä¸­å­˜å‚¨å±å¹•å›¾åƒçš„å†…å­˜åŒºåŸŸã€‚

**çº¿æ€§å¸§ç¼“å†²**ï¼š
- å±å¹•åƒç´ æŒ‰è¡Œè¿ç»­å­˜å‚¨
- åƒç´ åœ°å€ = åŸºåœ°å€ + y Ã— pitch + x Ã— bytes_per_pixel
- æ— éœ€å¤„ç†å†…å­˜åˆ†é¡µï¼ˆbank switchingï¼‰

**åƒç´ æ ¼å¼**ï¼ˆä»¥ 32bpp ä¸ºä¾‹ï¼‰ï¼š
```
32bpp ARGB (8-8-8-8):
  31-24: Alpha (æˆ–ä¿ç•™)
  23-16: Red
  15-8:  Green
  7-0:   Blue

24bpp BGR:
  23-16: Blue
  15-8:  Green
  7-0:   Red
```

### ATI Radeon å¯„å­˜å™¨æ¶æ„

**å†…å­˜æ˜ å°„ I/Oï¼ˆMMIOï¼‰**ï¼š
- BAR0ï¼šå¸§ç¼“å†²å†…å­˜ï¼ˆæ˜¾å­˜ï¼‰
- BAR2ï¼šMMIO å¯„å­˜å™¨

**å…³é”®å¯„å­˜å™¨ç»„**ï¼š
```
CRTC å¯„å­˜å™¨ (0x0200-0x03FF)ï¼šæ˜¾ç¤ºæ—¶åºæ§åˆ¶
DAC å¯„å­˜å™¨ (0x0400-0x04FF)ï¼šè°ƒè‰²æ¿å’Œè¾“å‡ºæ§åˆ¶
OV0 å¯„å­˜å™¨ (0x0800-0x08FF)ï¼šè§†é¢‘å åŠ 
2D å¯„å­˜å™¨ (0x1400-0x17FF)ï¼š2D å¼•æ“
```

**æ¨¡å¼è®¾ç½®æµç¨‹**ï¼š
1. ç¦ç”¨æ˜¾ç¤ºè¾“å‡º
2. é…ç½® PLLï¼ˆæ—¶é’Ÿç”Ÿæˆå™¨ï¼‰
3. è®¾ç½® CRTC æ—¶åºå‚æ•°
4. é…ç½®æ˜¾å­˜æ˜ å°„
5. å¯ç”¨æ˜¾ç¤ºè¾“å‡º

### å¤šåˆ†è¾¨ç‡æ”¯æŒç­–ç•¥

IBM ThinkPad T41 æœ‰ä¸¤ç§å±å¹•é…ç½®ï¼Œéœ€è¦åœ¨å¯åŠ¨æ—¶è‡ªåŠ¨æ£€æµ‹å¹¶é€‚é…ï¼š

| å‹å· | åˆ†è¾¨ç‡ | å®½é«˜æ¯” | åƒç´ æ—¶é’Ÿ | æ˜¾å­˜éœ€æ±‚ |
|------|--------|--------|----------|----------|
| XGA | 1024Ã—768 | 4:3 | 65 MHz | 3 MB (32bpp) |
| SXGA+ | 1400Ã—1050 | 4:3 | 108 MHz | 5.6 MB (32bpp) |

**æ£€æµ‹æ–¹æ¡ˆå¯¹æ¯”**ï¼š

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | æ¨èåº¦ |
|------|------|------|--------|
| GRUB è‡ªåŠ¨æ£€æµ‹ | æœ€ç®€å•ï¼Œæ— éœ€å†…æ ¸ä»£ç  | ä¾èµ– GRUB æ”¯æŒ | â­â­â­â­â­ |
| EDID è¯»å– | ç²¾ç¡®æ£€æµ‹æ˜¾ç¤ºå™¨å‚æ•° | éœ€è¦ I2C/DDC é©±åŠ¨ | â­â­â­â­ |
| VESA æ¨¡å¼æšä¸¾ | åˆ—å‡ºæ‰€æœ‰æ”¯æŒçš„æ¨¡å¼ | éœ€è¦å®æ¨¡å¼è°ƒç”¨ | â­â­â­ |
| ç¡¬ç¼–ç  + ç”¨æˆ·é€‰æ‹© | ç®€å•å¯é  | ç”¨æˆ·ä½“éªŒå·® | â­â­ |

**æ¨èæ–¹æ¡ˆï¼šGRUB è‡ªåŠ¨æ£€æµ‹ + EDID éªŒè¯**

1. **å¼•å¯¼é˜¶æ®µ**ï¼šGRUB å°è¯•è®¾ç½®æœ€é«˜å¯ç”¨åˆ†è¾¨ç‡
2. **å†…æ ¸é˜¶æ®µ**ï¼šé€šè¿‡ EDID éªŒè¯å¹¶è®°å½•æ˜¾ç¤ºå™¨ä¿¡æ¯
3. **è¿è¡Œæ—¶**ï¼šæ”¯æŒç”¨æˆ·æ‰‹åŠ¨åˆ‡æ¢åˆ†è¾¨ç‡ï¼ˆæœªæ¥æ‰©å±•ï¼‰

### EDIDï¼ˆExtended Display Identification Dataï¼‰

**EDID** æ˜¯æ˜¾ç¤ºå™¨é€šè¿‡ DDCï¼ˆDisplay Data Channelï¼‰ä¼ è¾“çš„æ ‡è¯†æ•°æ®ï¼ŒåŒ…å«ï¼š
- åˆ¶é€ å•†ä¿¡æ¯
- äº§å“å‹å·
- **é¦–é€‰åˆ†è¾¨ç‡ï¼ˆåŸç”Ÿåˆ†è¾¨ç‡ï¼‰**
- æ”¯æŒçš„æ˜¾ç¤ºæ¨¡å¼åˆ—è¡¨
- ç‰©ç†å°ºå¯¸

**EDID è¯»å–æ–¹å¼**ï¼š
```
æ˜¾å¡ GPIO/I2C å¼•è„š <--DDC--> LCD é¢æ¿ EDID ROM
```

**ATI Radeon çš„ DDC ç«¯å£**ï¼š
- `GPIO_VGA_DDC` (0x0060)ï¼šVGA æ¥å£ DDC
- `GPIO_DVI_DDC` (0x0064)ï¼šDVI/LVDS æ¥å£ DDCï¼ˆå†…ç½® LCDï¼‰

**EDID æ•°æ®ç»“æ„**ï¼ˆæ ‡å‡† 128 å­—èŠ‚ï¼‰ï¼š
```c
typedef struct edid_block {
    uint8_t  header[8];           // å›ºå®šå¤´ï¼š00 FF FF FF FF FF FF 00
    uint16_t manufacturer_id;     // åˆ¶é€ å•† IDï¼ˆå‹ç¼© ASCIIï¼‰
    uint16_t product_code;        // äº§å“ä»£ç 
    uint32_t serial_number;       // åºåˆ—å·
    uint8_t  week_of_manufacture; // ç”Ÿäº§å‘¨
    uint8_t  year_of_manufacture; // ç”Ÿäº§å¹´ä»½ï¼ˆç›¸å¯¹ 1990ï¼‰
    uint8_t  edid_version;        // EDID ç‰ˆæœ¬
    uint8_t  edid_revision;       // EDID ä¿®è®¢
    uint8_t  video_input;         // è§†é¢‘è¾“å…¥å®šä¹‰
    uint8_t  max_horiz_size;      // æœ€å¤§æ°´å¹³å°ºå¯¸ï¼ˆcmï¼‰
    uint8_t  max_vert_size;       // æœ€å¤§å‚ç›´å°ºå¯¸ï¼ˆcmï¼‰
    uint8_t  gamma;               // Gamma å€¼
    uint8_t  feature_support;     // ç‰¹æ€§æ”¯æŒ
    // ... è‰²åº¦åæ ‡ã€æ—¶åºä¿¡æ¯ç­‰
    uint8_t  detailed_timing[4][18]; // è¯¦ç»†æ—¶åºæè¿°ç¬¦
    uint8_t  extension_flag;      // æ‰©å±•å—æ•°é‡
    uint8_t  checksum;            // æ ¡éªŒå’Œ
} __attribute__((packed)) edid_block_t;
```

**ä» EDID æå–é¦–é€‰åˆ†è¾¨ç‡**ï¼ˆç¬¬ä¸€ä¸ªè¯¦ç»†æ—¶åºæè¿°ç¬¦ï¼‰ï¼š
```c
// è¯¦ç»†æ—¶åºæè¿°ç¬¦æ ¼å¼ï¼ˆ18 å­—èŠ‚ï¼‰
// åç§» 0-1: åƒç´ æ—¶é’Ÿï¼ˆÃ—10 kHzï¼‰
// åç§» 2: æ°´å¹³æ´»åŠ¨åƒç´ ä½ 8 ä½
// åç§» 4: æ°´å¹³æ´»åŠ¨åƒç´ é«˜ 4 ä½ + æ°´å¹³æ¶ˆéšé«˜ 4 ä½
// åç§» 5: å‚ç›´æ´»åŠ¨è¡Œä½ 8 ä½
// åç§» 7: å‚ç›´æ´»åŠ¨è¡Œé«˜ 4 ä½ + å‚ç›´æ¶ˆéšé«˜ 4 ä½

uint16_t pixel_clock = (dtd[1] << 8) | dtd[0];  // Ã—10 kHz
uint16_t h_active = dtd[2] | ((dtd[4] & 0xF0) << 4);
uint16_t v_active = dtd[5] | ((dtd[7] & 0xF0) << 4);
```

---

## å®ç°è®¾è®¡

### 1. PCI æ€»çº¿é©±åŠ¨

**å¤´æ–‡ä»¶**: `src/include/drivers/pci.h`

```c
#ifndef _DRIVERS_PCI_H_
#define _DRIVERS_PCI_H_

#include <types.h>

/* PCI é…ç½®ç©ºé—´ç«¯å£ */
#define PCI_CONFIG_ADDRESS  0xCF8
#define PCI_CONFIG_DATA     0xCFC

/* PCI é…ç½®ç©ºé—´å¯„å­˜å™¨åç§» */
#define PCI_VENDOR_ID       0x00
#define PCI_DEVICE_ID       0x02
#define PCI_COMMAND         0x04
#define PCI_STATUS          0x06
#define PCI_REVISION_ID     0x08
#define PCI_CLASS_CODE      0x09
#define PCI_CACHE_LINE      0x0C
#define PCI_LATENCY_TIMER   0x0D
#define PCI_HEADER_TYPE     0x0E
#define PCI_BAR0            0x10
#define PCI_BAR1            0x14
#define PCI_BAR2            0x18
#define PCI_BAR3            0x1C
#define PCI_BAR4            0x20
#define PCI_BAR5            0x24
#define PCI_INTERRUPT_LINE  0x3C
#define PCI_INTERRUPT_PIN   0x3D

/* PCI è®¾å¤‡ç±»åˆ« */
#define PCI_CLASS_DISPLAY       0x03
#define PCI_SUBCLASS_VGA        0x00

/* ATI å‚å•† ID */
#define PCI_VENDOR_ATI          0x1002
#define PCI_DEVICE_RADEON_7500  0x4C57  /* RV200 Mobility Radeon 7500 */
#define PCI_DEVICE_RADEON_9000  0x4C66  /* RV250 Mobility Radeon 9000 */

/* PCI è®¾å¤‡ä¿¡æ¯ç»“æ„ */
typedef struct pci_device {
    uint8_t bus;
    uint8_t slot;
    uint8_t func;
    uint16_t vendor_id;
    uint16_t device_id;
    uint8_t class_code;
    uint8_t subclass;
    uint8_t prog_if;
    uint8_t revision;
    uint8_t header_type;
    uint8_t interrupt_line;
    uint8_t interrupt_pin;
    uint32_t bar[6];
} pci_device_t;

/* PCI å‡½æ•°å£°æ˜ */
void pci_init(void);

/* é…ç½®ç©ºé—´è¯»å†™ */
uint8_t pci_config_read8(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset);
uint16_t pci_config_read16(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset);
uint32_t pci_config_read32(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset);
void pci_config_write8(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset, uint8_t value);
void pci_config_write16(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset, uint16_t value);
void pci_config_write32(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset, uint32_t value);

/* è®¾å¤‡æšä¸¾ */
int pci_scan_devices(void);
pci_device_t *pci_find_device(uint16_t vendor_id, uint16_t device_id);
pci_device_t *pci_find_class(uint8_t class_code, uint8_t subclass);
void pci_print_devices(void);

/* BAR è§£æ */
uint32_t pci_get_bar_address(pci_device_t *dev, int bar_index);
uint32_t pci_get_bar_size(pci_device_t *dev, int bar_index);
bool pci_bar_is_mmio(pci_device_t *dev, int bar_index);

/* è®¾å¤‡æ§åˆ¶ */
void pci_enable_bus_master(pci_device_t *dev);
void pci_enable_memory_space(pci_device_t *dev);
void pci_enable_io_space(pci_device_t *dev);

#endif /* _DRIVERS_PCI_H_ */
```

**æ ¸å¿ƒåŠŸèƒ½**ï¼š

1. **é…ç½®ç©ºé—´è®¿é—®**ï¼šé€šè¿‡ I/O ç«¯å£ 0xCF8/0xCFC è¯»å†™ PCI é…ç½®ç©ºé—´
2. **è®¾å¤‡æšä¸¾**ï¼šæ‰«ææ‰€æœ‰æ€»çº¿/è®¾å¤‡/åŠŸèƒ½ï¼Œå‘ç°å·²è¿æ¥çš„è®¾å¤‡
3. **BAR è§£æ**ï¼šç¡®å®šè®¾å¤‡çš„å†…å­˜/IO èµ„æºåœ°å€å’Œå¤§å°
4. **è®¾å¤‡æ§åˆ¶**ï¼šå¯ç”¨æ€»çº¿ä¸»æ§ã€å†…å­˜ç©ºé—´è®¿é—®ç­‰

### 2. å¸§ç¼“å†²æŠ½è±¡å±‚

**å¤´æ–‡ä»¶**: `src/include/drivers/framebuffer.h`

```c
#ifndef _DRIVERS_FRAMEBUFFER_H_
#define _DRIVERS_FRAMEBUFFER_H_

#include <types.h>

/* åƒç´ æ ¼å¼ */
typedef enum {
    FB_FORMAT_RGB565,     // 16bpp: RRRRRGGGGGGBBBBB
    FB_FORMAT_RGB888,     // 24bpp: RRRRRRRRGGGGGGGGBBBBBBBB
    FB_FORMAT_ARGB8888,   // 32bpp: AAAAAAAARRRRRRRRGGGGGGGGBBBBBBBB
    FB_FORMAT_BGRA8888,   // 32bpp: BBBBBBBBGGGGGGGGRRRRRRRRAAAAAAAAA
} fb_format_t;

/* å¸§ç¼“å†²ä¿¡æ¯ç»“æ„ */
typedef struct framebuffer_info {
    uint32_t address;       // å¸§ç¼“å†²ç‰©ç†åœ°å€
    uint32_t *buffer;       // æ˜ å°„åçš„è™šæ‹Ÿåœ°å€
    uint32_t width;         // æ°´å¹³åˆ†è¾¨ç‡
    uint32_t height;        // å‚ç›´åˆ†è¾¨ç‡
    uint32_t pitch;         // æ¯è¡Œå­—èŠ‚æ•°
    uint8_t  bpp;           // æ¯åƒç´ ä½æ•°
    fb_format_t format;     // åƒç´ æ ¼å¼
    uint8_t  red_mask_size;
    uint8_t  red_field_pos;
    uint8_t  green_mask_size;
    uint8_t  green_field_pos;
    uint8_t  blue_mask_size;
    uint8_t  blue_field_pos;
} framebuffer_info_t;

/* é¢œè‰²ç»“æ„ */
typedef struct {
    uint8_t r, g, b, a;
} color_t;

/* é¢„å®šä¹‰é¢œè‰² */
#define COLOR_BLACK     (color_t){0, 0, 0, 255}
#define COLOR_WHITE     (color_t){255, 255, 255, 255}
#define COLOR_RED       (color_t){255, 0, 0, 255}
#define COLOR_GREEN     (color_t){0, 255, 0, 255}
#define COLOR_BLUE      (color_t){0, 0, 255, 255}
#define COLOR_YELLOW    (color_t){255, 255, 0, 255}
#define COLOR_CYAN      (color_t){0, 255, 255, 255}
#define COLOR_MAGENTA   (color_t){255, 0, 255, 255}

/* å¸§ç¼“å†²å‡½æ•° */
int fb_init(void);
framebuffer_info_t *fb_get_info(void);

/* åŸºç¡€ç»˜å›¾å‡½æ•° */
void fb_clear(color_t color);
void fb_put_pixel(int x, int y, color_t color);
color_t fb_get_pixel(int x, int y);
void fb_draw_hline(int x, int y, int length, color_t color);
void fb_draw_vline(int x, int y, int length, color_t color);
void fb_draw_line(int x1, int y1, int x2, int y2, color_t color);
void fb_draw_rect(int x, int y, int width, int height, color_t color);
void fb_fill_rect(int x, int y, int width, int height, color_t color);

/* ä½å›¾æ“ä½œ */
void fb_blit(int x, int y, int width, int height, const uint32_t *data);
void fb_copy_rect(int src_x, int src_y, int dst_x, int dst_y, int width, int height);

/* æ–‡æœ¬æ¸²æŸ“ï¼ˆåŸºäºä½å›¾å­—ä½“ï¼‰ */
void fb_set_font(const uint8_t *font_data, int char_width, int char_height);
void fb_draw_char(int x, int y, char c, color_t fg, color_t bg);
void fb_draw_string(int x, int y, const char *str, color_t fg, color_t bg);

/* åŒç¼“å†²æ”¯æŒï¼ˆå¯é€‰ï¼‰ */
void fb_swap_buffers(void);
void fb_set_double_buffer(bool enable);

#endif /* _DRIVERS_FRAMEBUFFER_H_ */
```

### 3. VESA VBE é©±åŠ¨

**è®¾è®¡æ–¹æ¡ˆ**ï¼š

ç”±äº VBE è°ƒç”¨éœ€è¦ BIOS ä¸­æ–­ï¼Œæœ‰ä»¥ä¸‹å®ç°é€‰æ‹©ï¼š

**æ–¹æ¡ˆ Aï¼šMultiboot2 å¸§ç¼“å†²ï¼ˆæ¨èï¼‰**
- åœ¨ GRUB å¼•å¯¼æ—¶è®¾ç½®å›¾å½¢æ¨¡å¼
- å†…æ ¸é€šè¿‡ Multiboot2 ä¿¡æ¯ç»“æ„è·å–å¸§ç¼“å†²åœ°å€
- æœ€ç®€å•ï¼Œæ— éœ€å¤æ‚çš„å®æ¨¡å¼åˆ‡æ¢

**æ–¹æ¡ˆ Bï¼šV86 æ¨¡å¼è°ƒç”¨ BIOS**
- å®ç°è™šæ‹Ÿ 8086 æ¨¡å¼
- åœ¨ä¿æŠ¤æ¨¡å¼ä¸‹è°ƒç”¨ VBE BIOS
- è¾ƒå¤æ‚ï¼Œä½†çµæ´»æ€§é«˜

**æ–¹æ¡ˆ Cï¼šç›´æ¥æ¨¡å¼è®¾ç½®**
- ç›´æ¥æ“ä½œæ˜¾å¡å¯„å­˜å™¨
- ä¸ä¾èµ– BIOS
- éœ€è¦æ˜¾å¡ç‰¹å®šçš„ä»£ç 

**æ¨èé‡‡ç”¨æ–¹æ¡ˆ A**ï¼Œä¿®æ”¹ Multiboot å¤´éƒ¨ä»¥è¯·æ±‚å›¾å½¢æ¨¡å¼ï¼š

```nasm
; multiboot2.asm - Multiboot2 å¤´éƒ¨ï¼ˆæ”¯æŒå›¾å½¢æ¨¡å¼ï¼‰
section .multiboot2
align 8

multiboot2_header:
    dd 0xE85250D6                   ; Multiboot2 é­”æ•°
    dd 0                            ; æ¶æ„ï¼ši386
    dd multiboot2_header_end - multiboot2_header  ; å¤´éƒ¨é•¿åº¦
    dd -(0xE85250D6 + 0 + (multiboot2_header_end - multiboot2_header))  ; æ ¡éªŒå’Œ

    ; å¸§ç¼“å†²æ ‡ç­¾
framebuffer_tag:
    dw 5                            ; ç±»å‹ï¼šframebuffer
    dw 0                            ; æ ‡å¿—
    dd framebuffer_tag_end - framebuffer_tag
    dd 1024                         ; é¦–é€‰å®½åº¦
    dd 768                          ; é¦–é€‰é«˜åº¦
    dd 32                           ; é¦–é€‰ä½æ·±åº¦
framebuffer_tag_end:
    align 8

    ; ç»“æŸæ ‡ç­¾
    dw 0                            ; ç±»å‹ï¼šç»“æŸ
    dw 0                            ; æ ‡å¿—
    dd 8                            ; å¤§å°
multiboot2_header_end:
```

### 4. ATI Radeon é©±åŠ¨ï¼ˆå¯é€‰ï¼‰

**å¤´æ–‡ä»¶**: `src/include/drivers/radeon.h`

```c
#ifndef _DRIVERS_RADEON_H_
#define _DRIVERS_RADEON_H_

#include <types.h>
#include <drivers/pci.h>
#include <drivers/framebuffer.h>

/* Radeon å¯„å­˜å™¨åç§» */
#define RADEON_MM_INDEX         0x0000
#define RADEON_MM_DATA          0x0004
#define RADEON_BIOS_SCRATCH_0   0x0010
#define RADEON_GEN_INT_CNTL     0x0040
#define RADEON_GEN_INT_STATUS   0x0044
#define RADEON_CRTC_GEN_CNTL    0x0050
#define RADEON_CRTC_EXT_CNTL    0x0054
#define RADEON_DAC_CNTL         0x0058
#define RADEON_CRTC_STATUS      0x005C
#define RADEON_GPIO_VGA_DDC     0x0060
#define RADEON_GPIO_DVI_DDC     0x0064
#define RADEON_PALETTE_INDEX    0x00B0
#define RADEON_PALETTE_DATA     0x00B4
#define RADEON_CRTC_H_TOTAL_DISP    0x0200
#define RADEON_CRTC_H_SYNC_STRT_WID 0x0204
#define RADEON_CRTC_V_TOTAL_DISP    0x0208
#define RADEON_CRTC_V_SYNC_STRT_WID 0x020C
#define RADEON_CRTC_OFFSET      0x0224
#define RADEON_CRTC_OFFSET_CNTL 0x0228
#define RADEON_CRTC_PITCH       0x022C
#define RADEON_OVR_CLR          0x0230
#define RADEON_OVR_WID_LEFT_RIGHT   0x0234
#define RADEON_OVR_WID_TOP_BOTTOM   0x0238
#define RADEON_DISPLAY_BASE_ADDR    0x023C
#define RADEON_SNAPSHOT_VH_COUNTS   0x0240
#define RADEON_SNAPSHOT_F_COUNT     0x0244
#define RADEON_CRTC_GUI_TRIG_VLINE  0x0218
#define RADEON_SURFACE_CNTL     0x0B00
#define RADEON_SURFACE0_INFO    0x0B0C
#define RADEON_SURFACE0_LOWER_BOUND 0x0B04
#define RADEON_SURFACE0_UPPER_BOUND 0x0B08
#define RADEON_DEFAULT_OFFSET   0x16E0
#define RADEON_DEFAULT_PITCH    0x16E4
#define RADEON_DEFAULT_SC_BOTTOM_RIGHT  0x16E8
#define RADEON_DP_GUI_MASTER_CNTL   0x146C
#define RADEON_DP_BRUSH_BKGD_CLR    0x1478
#define RADEON_DP_BRUSH_FRGD_CLR    0x147C
#define RADEON_DP_WRITE_MASK    0x16CC
#define RADEON_DP_CNTL          0x16C0
#define RADEON_DST_OFFSET       0x1404
#define RADEON_DST_PITCH        0x1408
#define RADEON_DST_WIDTH        0x140C
#define RADEON_DST_HEIGHT       0x1410
#define RADEON_DST_Y_X          0x1438
#define RADEON_SRC_OFFSET       0x15AC
#define RADEON_SRC_PITCH        0x15B0
#define RADEON_SRC_Y_X          0x1434
#define RADEON_GUI_STAT         0x14E4

/* Radeon è®¾å¤‡ç»“æ„ */
typedef struct radeon_device {
    pci_device_t *pci_dev;
    volatile uint32_t *mmio;        // MMIO å¯„å­˜å™¨åŸºåœ°å€
    volatile uint32_t *fb;          // å¸§ç¼“å†²åŸºåœ°å€
    uint32_t fb_size;               // æ˜¾å­˜å¤§å°
    uint32_t mmio_size;             // MMIO åŒºåŸŸå¤§å°
    uint32_t chip_id;               // èŠ¯ç‰‡ ID
    bool is_mobility;               // æ˜¯å¦ä¸ºç§»åŠ¨ç‰ˆ
    framebuffer_info_t fb_info;     // å¸§ç¼“å†²ä¿¡æ¯
} radeon_device_t;

/* Radeon é©±åŠ¨å‡½æ•° */
int radeon_init(void);
radeon_device_t *radeon_get_device(void);

/* å¯„å­˜å™¨è®¿é—® */
uint32_t radeon_read_reg(radeon_device_t *dev, uint32_t reg);
void radeon_write_reg(radeon_device_t *dev, uint32_t reg, uint32_t value);

/* æ¨¡å¼è®¾ç½® */
int radeon_set_mode(radeon_device_t *dev, uint32_t width, uint32_t height, uint32_t bpp);
int radeon_get_modes(radeon_device_t *dev, void *mode_list, int max_modes);

/* 2D åŠ é€Ÿ */
void radeon_wait_idle(radeon_device_t *dev);
void radeon_fill_rect(radeon_device_t *dev, int x, int y, int w, int h, uint32_t color);
void radeon_copy_rect(radeon_device_t *dev, int sx, int sy, int dx, int dy, int w, int h);

#endif /* _DRIVERS_RADEON_H_ */
```

---

## å®ç°æ­¥éª¤

### æ­¥éª¤ 1: å®ç° PCI æ€»çº¿é©±åŠ¨

PCI é©±åŠ¨æ˜¯è®¿é—®æ˜¾å¡çš„åŸºç¡€ã€‚

**æ–‡ä»¶**: `src/include/drivers/pci.h`
**æ–‡ä»¶**: `src/drivers/pci.c`

**æ ¸å¿ƒå®ç°**ï¼š

```c
// pci.c - PCI æ€»çº¿é©±åŠ¨æ ¸å¿ƒå®ç°

#include <drivers/pci.h>
#include <kernel/io.h>
#include <lib/kprintf.h>
#include <lib/string.h>
#include <mm/heap.h>

/* æœ€å¤§æ”¯æŒçš„ PCI è®¾å¤‡æ•° */
#define MAX_PCI_DEVICES 64

/* å·²å‘ç°çš„è®¾å¤‡åˆ—è¡¨ */
static pci_device_t pci_devices[MAX_PCI_DEVICES];
static int pci_device_count = 0;

/**
 * æ„é€  PCI é…ç½®ç©ºé—´åœ°å€
 */
static uint32_t pci_make_address(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset) {
    return (uint32_t)((1 << 31) |              // Enable bit
                      ((uint32_t)bus << 16) |   // Bus number
                      ((uint32_t)slot << 11) |  // Device number
                      ((uint32_t)func << 8) |   // Function number
                      (offset & 0xFC));         // Register offset (aligned)
}

/**
 * è¯»å– PCI é…ç½®ç©ºé—´ï¼ˆ32ä½ï¼‰
 */
uint32_t pci_config_read32(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset) {
    uint32_t address = pci_make_address(bus, slot, func, offset);
    outl(PCI_CONFIG_ADDRESS, address);
    return inl(PCI_CONFIG_DATA);
}

/**
 * è¯»å– PCI é…ç½®ç©ºé—´ï¼ˆ16ä½ï¼‰
 */
uint16_t pci_config_read16(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset) {
    uint32_t value = pci_config_read32(bus, slot, func, offset & ~3);
    return (uint16_t)((value >> ((offset & 2) * 8)) & 0xFFFF);
}

/**
 * è¯»å– PCI é…ç½®ç©ºé—´ï¼ˆ8ä½ï¼‰
 */
uint8_t pci_config_read8(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset) {
    uint32_t value = pci_config_read32(bus, slot, func, offset & ~3);
    return (uint8_t)((value >> ((offset & 3) * 8)) & 0xFF);
}

/**
 * æ‰«æ PCI è®¾å¤‡
 */
int pci_scan_devices(void) {
    pci_device_count = 0;
    
    for (uint16_t bus = 0; bus < 256; bus++) {
        for (uint8_t slot = 0; slot < 32; slot++) {
            for (uint8_t func = 0; func < 8; func++) {
                uint16_t vendor = pci_config_read16(bus, slot, func, PCI_VENDOR_ID);
                
                // æ— æ•ˆçš„ Vendor ID è¡¨ç¤ºè®¾å¤‡ä¸å­˜åœ¨
                if (vendor == 0xFFFF) {
                    if (func == 0) break;  // éå¤šåŠŸèƒ½è®¾å¤‡
                    continue;
                }
                
                if (pci_device_count >= MAX_PCI_DEVICES) {
                    return pci_device_count;
                }
                
                pci_device_t *dev = &pci_devices[pci_device_count++];
                dev->bus = bus;
                dev->slot = slot;
                dev->func = func;
                dev->vendor_id = vendor;
                dev->device_id = pci_config_read16(bus, slot, func, PCI_DEVICE_ID);
                
                uint32_t class_info = pci_config_read32(bus, slot, func, PCI_CLASS_CODE);
                dev->class_code = (class_info >> 24) & 0xFF;
                dev->subclass = (class_info >> 16) & 0xFF;
                dev->prog_if = (class_info >> 8) & 0xFF;
                dev->revision = class_info & 0xFF;
                
                dev->header_type = pci_config_read8(bus, slot, func, PCI_HEADER_TYPE);
                dev->interrupt_line = pci_config_read8(bus, slot, func, PCI_INTERRUPT_LINE);
                dev->interrupt_pin = pci_config_read8(bus, slot, func, PCI_INTERRUPT_PIN);
                
                // è¯»å– BAR
                for (int i = 0; i < 6; i++) {
                    dev->bar[i] = pci_config_read32(bus, slot, func, PCI_BAR0 + i * 4);
                }
                
                // å¦‚æœä¸æ˜¯å¤šåŠŸèƒ½è®¾å¤‡ï¼Œè·³è¿‡å…¶ä»– function
                if (func == 0 && !(dev->header_type & 0x80)) {
                    break;
                }
            }
        }
    }
    
    return pci_device_count;
}

/**
 * æŸ¥æ‰¾æŒ‡å®š Vendor/Device ID çš„è®¾å¤‡
 */
pci_device_t *pci_find_device(uint16_t vendor_id, uint16_t device_id) {
    for (int i = 0; i < pci_device_count; i++) {
        if (pci_devices[i].vendor_id == vendor_id &&
            pci_devices[i].device_id == device_id) {
            return &pci_devices[i];
        }
    }
    return NULL;
}

/**
 * æŸ¥æ‰¾æŒ‡å®šç±»åˆ«çš„è®¾å¤‡
 */
pci_device_t *pci_find_class(uint8_t class_code, uint8_t subclass) {
    for (int i = 0; i < pci_device_count; i++) {
        if (pci_devices[i].class_code == class_code &&
            pci_devices[i].subclass == subclass) {
            return &pci_devices[i];
        }
    }
    return NULL;
}
```

### æ­¥éª¤ 2: å®ç°å¸§ç¼“å†²é©±åŠ¨

åŸºäº Multiboot ä¿¡æ¯å®ç°å¸§ç¼“å†²ã€‚

**æ–‡ä»¶**: `src/include/drivers/framebuffer.h`
**æ–‡ä»¶**: `src/drivers/framebuffer.c`

**æ ¸å¿ƒå®ç°**ï¼š

```c
// framebuffer.c - å¸§ç¼“å†²é©±åŠ¨å®ç°

#include <drivers/framebuffer.h>
#include <kernel/multiboot.h>
#include <mm/vmm.h>
#include <lib/string.h>

static framebuffer_info_t fb_info;
static bool fb_initialized = false;

/* 8x16 ä½å›¾å­—ä½“ï¼ˆä»…ç¤ºä¾‹ï¼Œå®é™…éœ€å®Œæ•´å­—ä½“æ•°æ®ï¼‰ */
static const uint8_t *current_font = NULL;
static int font_width = 8;
static int font_height = 16;

/**
 * ä» Multiboot ä¿¡æ¯åˆå§‹åŒ–å¸§ç¼“å†²
 */
int fb_init_from_multiboot(multiboot_info_t *mbi) {
    if (!(mbi->flags & MULTIBOOT_INFO_FRAMEBUFFER_INFO)) {
        return -1;  // æ²¡æœ‰å¸§ç¼“å†²ä¿¡æ¯
    }
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºå›¾å½¢æ¨¡å¼ï¼ˆç±»å‹ 1 = å›¾å½¢ï¼Œ0 = æ–‡æœ¬ï¼‰
    if (mbi->framebuffer_type != 1) {
        return -2;  // ä¸æ˜¯å›¾å½¢æ¨¡å¼
    }
    
    fb_info.address = (uint32_t)mbi->framebuffer_addr;
    fb_info.width = mbi->framebuffer_width;
    fb_info.height = mbi->framebuffer_height;
    fb_info.pitch = mbi->framebuffer_pitch;
    fb_info.bpp = mbi->framebuffer_bpp;
    
    fb_info.red_mask_size = mbi->framebuffer_red_mask_size;
    fb_info.red_field_pos = mbi->framebuffer_red_field_position;
    fb_info.green_mask_size = mbi->framebuffer_green_mask_size;
    fb_info.green_field_pos = mbi->framebuffer_green_field_position;
    fb_info.blue_mask_size = mbi->framebuffer_blue_mask_size;
    fb_info.blue_field_pos = mbi->framebuffer_blue_field_position;
    
    // ç¡®å®šåƒç´ æ ¼å¼
    if (fb_info.bpp == 32) {
        if (fb_info.red_field_pos == 16) {
            fb_info.format = FB_FORMAT_ARGB8888;
        } else {
            fb_info.format = FB_FORMAT_BGRA8888;
        }
    } else if (fb_info.bpp == 24) {
        fb_info.format = FB_FORMAT_RGB888;
    } else if (fb_info.bpp == 16) {
        fb_info.format = FB_FORMAT_RGB565;
    }
    
    // æ˜ å°„å¸§ç¼“å†²åˆ°è™šæ‹Ÿåœ°å€ç©ºé—´
    uint32_t fb_size = fb_info.pitch * fb_info.height;
    uint32_t fb_pages = (fb_size + PAGE_SIZE - 1) / PAGE_SIZE;
    
    // å°†å¸§ç¼“å†²æ˜ å°„åˆ°å†…æ ¸è™šæ‹Ÿåœ°å€ç©ºé—´
    fb_info.buffer = (uint32_t *)vmm_map_physical(fb_info.address, fb_pages, 
                                                   VMM_FLAG_PRESENT | VMM_FLAG_WRITE);
    if (!fb_info.buffer) {
        return -3;  // æ˜ å°„å¤±è´¥
    }
    
    fb_initialized = true;
    return 0;
}

/**
 * å°† color_t è½¬æ¢ä¸ºåƒç´ å€¼
 */
static inline uint32_t color_to_pixel(color_t c) {
    switch (fb_info.format) {
        case FB_FORMAT_ARGB8888:
            return (c.a << 24) | (c.r << 16) | (c.g << 8) | c.b;
        case FB_FORMAT_BGRA8888:
            return (c.b << 24) | (c.g << 16) | (c.r << 8) | c.a;
        case FB_FORMAT_RGB888:
            return (c.r << 16) | (c.g << 8) | c.b;
        case FB_FORMAT_RGB565:
            return ((c.r >> 3) << 11) | ((c.g >> 2) << 5) | (c.b >> 3);
        default:
            return 0;
    }
}

/**
 * æ¸…å±
 */
void fb_clear(color_t color) {
    if (!fb_initialized) return;
    
    uint32_t pixel = color_to_pixel(color);
    uint32_t *p = fb_info.buffer;
    uint32_t count = (fb_info.pitch * fb_info.height) / 4;
    
    for (uint32_t i = 0; i < count; i++) {
        p[i] = pixel;
    }
}

/**
 * ç»˜åˆ¶åƒç´ 
 */
void fb_put_pixel(int x, int y, color_t color) {
    if (!fb_initialized) return;
    if (x < 0 || x >= (int)fb_info.width || y < 0 || y >= (int)fb_info.height) return;
    
    uint32_t pixel = color_to_pixel(color);
    uint32_t offset = y * fb_info.pitch + x * (fb_info.bpp / 8);
    
    if (fb_info.bpp == 32) {
        *((uint32_t *)((uint8_t *)fb_info.buffer + offset)) = pixel;
    } else if (fb_info.bpp == 24) {
        uint8_t *p = (uint8_t *)fb_info.buffer + offset;
        p[0] = pixel & 0xFF;
        p[1] = (pixel >> 8) & 0xFF;
        p[2] = (pixel >> 16) & 0xFF;
    } else if (fb_info.bpp == 16) {
        *((uint16_t *)((uint8_t *)fb_info.buffer + offset)) = (uint16_t)pixel;
    }
}

/**
 * å¡«å……çŸ©å½¢
 */
void fb_fill_rect(int x, int y, int width, int height, color_t color) {
    if (!fb_initialized) return;
    
    // è£å‰ªåˆ°å±å¹•èŒƒå›´
    if (x < 0) { width += x; x = 0; }
    if (y < 0) { height += y; y = 0; }
    if (x + width > (int)fb_info.width) { width = fb_info.width - x; }
    if (y + height > (int)fb_info.height) { height = fb_info.height - y; }
    if (width <= 0 || height <= 0) return;
    
    uint32_t pixel = color_to_pixel(color);
    uint32_t bytes_per_pixel = fb_info.bpp / 8;
    
    for (int row = 0; row < height; row++) {
        uint8_t *line = (uint8_t *)fb_info.buffer + (y + row) * fb_info.pitch + x * bytes_per_pixel;
        
        if (fb_info.bpp == 32) {
            uint32_t *p = (uint32_t *)line;
            for (int col = 0; col < width; col++) {
                p[col] = pixel;
            }
        }
    }
}

/**
 * ç»˜åˆ¶å­—ç¬¦ï¼ˆ8x16 ä½å›¾å­—ä½“ï¼‰
 */
void fb_draw_char(int x, int y, char c, color_t fg, color_t bg) {
    if (!fb_initialized || !current_font) return;
    
    const uint8_t *glyph = current_font + (unsigned char)c * font_height;
    
    for (int row = 0; row < font_height; row++) {
        uint8_t bits = glyph[row];
        for (int col = 0; col < font_width; col++) {
            color_t color = (bits & (0x80 >> col)) ? fg : bg;
            fb_put_pixel(x + col, y + row, color);
        }
    }
}

/**
 * ç»˜åˆ¶å­—ç¬¦ä¸²
 */
void fb_draw_string(int x, int y, const char *str, color_t fg, color_t bg) {
    if (!str) return;
    
    int cx = x;
    while (*str) {
        if (*str == '\n') {
            cx = x;
            y += font_height;
        } else {
            fb_draw_char(cx, y, *str, fg, bg);
            cx += font_width;
        }
        str++;
    }
}

/**
 * è·å–å¸§ç¼“å†²ä¿¡æ¯
 */
framebuffer_info_t *fb_get_info(void) {
    return fb_initialized ? &fb_info : NULL;
}
```

### æ­¥éª¤ 3: ä¿®æ”¹ Multiboot å¤´éƒ¨æ”¯æŒå›¾å½¢æ¨¡å¼

**æ–‡ä»¶**: `src/boot/multiboot.asm`

**å…³é”®ç‚¹**ï¼šå°† width å’Œ height è®¾ä¸º 0ï¼Œè®© GRUB è‡ªåŠ¨é€‰æ‹©æœ€ä½³åˆ†è¾¨ç‡ï¼š

```nasm
; ============================================================================
; multiboot.asm - Multiboot å¤´éƒ¨ï¼ˆæ”¯æŒå›¾å½¢æ¨¡å¼ï¼‰
; ============================================================================

section .multiboot
align 4

; Multiboot å¸¸é‡å®šä¹‰
MULTIBOOT_MAGIC        equ 0x1BADB002
MULTIBOOT_PAGE_ALIGN   equ 1 << 0      ; é¡µå¯¹é½
MULTIBOOT_MEMORY_INFO  equ 1 << 1      ; å†…å­˜ä¿¡æ¯
MULTIBOOT_VIDEO_MODE   equ 1 << 2      ; è§†é¢‘æ¨¡å¼ä¿¡æ¯
MULTIBOOT_FLAGS        equ MULTIBOOT_PAGE_ALIGN | MULTIBOOT_MEMORY_INFO | MULTIBOOT_VIDEO_MODE
MULTIBOOT_CHECKSUM     equ -(MULTIBOOT_MAGIC + MULTIBOOT_FLAGS)

; Multiboot å¤´éƒ¨ç»“æ„
multiboot_header:
    dd MULTIBOOT_MAGIC              ; é­”æ•°
    dd MULTIBOOT_FLAGS              ; æ ‡å¿—
    dd MULTIBOOT_CHECKSUM           ; æ ¡éªŒå’Œ
    ; ä»¥ä¸‹å­—æ®µä»…åœ¨ flags[16] ç½®ä½æ—¶ä½¿ç”¨ï¼ˆæˆ‘ä»¬ä¸ä½¿ç”¨ï¼‰
    dd 0                            ; header_addr
    dd 0                            ; load_addr
    dd 0                            ; load_end_addr
    dd 0                            ; bss_end_addr
    dd 0                            ; entry_addr
    ; è§†é¢‘æ¨¡å¼å­—æ®µï¼ˆflags[2] ç½®ä½æ—¶ä½¿ç”¨ï¼‰
    dd 0                            ; mode_type: 0 = çº¿æ€§å›¾å½¢æ¨¡å¼
    dd 0                            ; width: 0 = è®© GRUB æ ¹æ® gfxmode é€‰æ‹©
    dd 0                            ; height: 0 = è®© GRUB æ ¹æ® gfxmode é€‰æ‹©
    dd 32                           ; depth: é¦–é€‰ä½æ·±åº¦
```

### æ­¥éª¤ 4: ä¿®æ”¹ grub.cfg é…ç½®å¤šåˆ†è¾¨ç‡æ”¯æŒ

**æ–‡ä»¶**: `grub.cfg`

**å¤šåˆ†è¾¨ç‡é…ç½®ç­–ç•¥**ï¼š

```
set timeout=3
set default=0

# ============================================================================
# å¤šåˆ†è¾¨ç‡æ”¯æŒé…ç½®
# ============================================================================
# GRUB ä¼šæŒ‰é¡ºåºå°è¯•è¿™äº›åˆ†è¾¨ç‡ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨çš„
# 1400x1050 (SXGA+) - ThinkPad T41 é«˜åˆ†å±
# 1024x768 (XGA)    - ThinkPad T41 æ ‡å‡†å±
# 800x600 (SVGA)    - åå¤‡åˆ†è¾¨ç‡
# ============================================================================

set gfxmode=1400x1050x32,1024x768x32,800x600x32,auto
set gfxpayload=keep

# åŠ è½½ GRUB å›¾å½¢ç»ˆç«¯ï¼ˆç”¨äºæ˜¾ç¤ºå¯åŠ¨èœå•ï¼‰
insmod all_video
insmod gfxterm
terminal_output gfxterm

menuentry "CastorOS (Auto Resolution)" {
    # gfxpayload=keep ä½¿ç”¨ gfxmode è®¾ç½®çš„åˆ†è¾¨ç‡
    set gfxpayload=keep
    multiboot /boot/castor.bin
    boot
}

menuentry "CastorOS (1400x1050 SXGA+)" {
    set gfxpayload=1400x1050x32
    multiboot /boot/castor.bin
    boot
}

menuentry "CastorOS (1024x768 XGA)" {
    set gfxpayload=1024x768x32
    multiboot /boot/castor.bin
    boot
}

menuentry "CastorOS (Text Mode)" {
    set gfxpayload=text
    multiboot /boot/castor.bin
    boot
}
```

**gfxmode è¯´æ˜**ï¼š
- ä½¿ç”¨é€—å·åˆ†éš”å¤šä¸ªåˆ†è¾¨ç‡ï¼ŒGRUB æŒ‰é¡ºåºå°è¯•
- `auto` è¡¨ç¤ºä½¿ç”¨æ˜¾ç¤ºå™¨/æ˜¾å¡çš„é»˜è®¤åˆ†è¾¨ç‡
- GRUB ä¼šè‡ªåŠ¨è·³è¿‡ä¸æ”¯æŒçš„åˆ†è¾¨ç‡

**éªŒè¯å½“å‰åˆ†è¾¨ç‡**ï¼šåœ¨ GRUB å‘½ä»¤è¡Œä¸­è¾“å…¥ `videoinfo` å¯æŸ¥çœ‹æ‰€æœ‰æ”¯æŒçš„åˆ†è¾¨ç‡

### æ­¥éª¤ 5: å®ç° EDID è¯»å–ï¼ˆå¯é€‰ï¼Œç”¨äºéªŒè¯/æ˜¾ç¤ºä¿¡æ¯ï¼‰

é€šè¿‡ ATI Radeon çš„ I2C/DDC æ¥å£è¯»å–æ˜¾ç¤ºå™¨ EDID ä¿¡æ¯ã€‚

**å¤´æ–‡ä»¶**: `src/include/drivers/edid.h`

```c
#ifndef _DRIVERS_EDID_H_
#define _DRIVERS_EDID_H_

#include <types.h>

/* EDID æ•°æ®å—å¤§å° */
#define EDID_BLOCK_SIZE 128

/* EDID ä¿¡æ¯ç»“æ„ */
typedef struct edid_info {
    bool valid;                      // EDID æ˜¯å¦æœ‰æ•ˆ
    char manufacturer[4];            // åˆ¶é€ å•† ID (3å­—ç¬¦ + null)
    uint16_t product_code;           // äº§å“ä»£ç 
    uint32_t serial_number;          // åºåˆ—å·
    uint8_t  week;                   // ç”Ÿäº§å‘¨
    uint16_t year;                   // ç”Ÿäº§å¹´ä»½
    uint8_t  version;                // EDID ç‰ˆæœ¬
    uint8_t  revision;               // EDID ä¿®è®¢
    uint16_t preferred_width;        // é¦–é€‰å®½åº¦ï¼ˆåŸç”Ÿåˆ†è¾¨ç‡ï¼‰
    uint16_t preferred_height;       // é¦–é€‰é«˜åº¦
    uint8_t  preferred_refresh;      // é¦–é€‰åˆ·æ–°ç‡
    uint8_t  max_horiz_size_cm;      // æœ€å¤§æ°´å¹³å°ºå¯¸ (cm)
    uint8_t  max_vert_size_cm;       // æœ€å¤§å‚ç›´å°ºå¯¸ (cm)
    bool is_digital;                 // æ˜¯å¦ä¸ºæ•°å­—æ˜¾ç¤ºå™¨
    uint8_t raw[EDID_BLOCK_SIZE];    // åŸå§‹ EDID æ•°æ®
} edid_info_t;

/* EDID å‡½æ•°å£°æ˜ */
int edid_read(edid_info_t *info);
int edid_read_from_radeon(void *mmio_base, edid_info_t *info);
void edid_print_info(const edid_info_t *info);
bool edid_validate(const uint8_t *data);

#endif /* _DRIVERS_EDID_H_ */
```

**å®ç°æ–‡ä»¶**: `src/drivers/edid.c`

```c
// edid.c - EDID è¯»å–å®ç°

#include <drivers/edid.h>
#include <drivers/radeon.h>
#include <lib/kprintf.h>
#include <lib/string.h>

/* I2C æ—¶åºå»¶è¿Ÿï¼ˆå¾®ç§’ï¼‰ */
#define I2C_DELAY_US 10

/* DDC I2C åœ°å€ */
#define DDC_ADDR_WRITE  0xA0  // EDID å†™åœ°å€
#define DDC_ADDR_READ   0xA1  // EDID è¯»åœ°å€

/* ATI Radeon GPIO å¯„å­˜å™¨ä½ */
#define GPIO_DDC_CLK_OUT    (1 << 0)   // SCL è¾“å‡º
#define GPIO_DDC_DATA_OUT   (1 << 8)   // SDA è¾“å‡º
#define GPIO_DDC_CLK_IN     (1 << 16)  // SCL è¾“å…¥
#define GPIO_DDC_DATA_IN    (1 << 24)  // SDA è¾“å…¥
#define GPIO_DDC_CLK_EN     (1 << 1)   // SCL è¾“å‡ºä½¿èƒ½
#define GPIO_DDC_DATA_EN    (1 << 9)   // SDA è¾“å‡ºä½¿èƒ½

/**
 * é€šè¿‡ Radeon GPIO å®ç° I2C bit-bang
 */
static void i2c_set_scl(volatile uint32_t *gpio_reg, bool high) {
    uint32_t val = *gpio_reg;
    if (high) {
        val |= GPIO_DDC_CLK_OUT;   // SCL = 1
    } else {
        val &= ~GPIO_DDC_CLK_OUT;  // SCL = 0
    }
    val |= GPIO_DDC_CLK_EN;        // å¯ç”¨è¾“å‡º
    *gpio_reg = val;
}

static void i2c_set_sda(volatile uint32_t *gpio_reg, bool high) {
    uint32_t val = *gpio_reg;
    if (high) {
        val |= GPIO_DDC_DATA_OUT;  // SDA = 1
    } else {
        val &= ~GPIO_DDC_DATA_OUT; // SDA = 0
    }
    val |= GPIO_DDC_DATA_EN;       // å¯ç”¨è¾“å‡º
    *gpio_reg = val;
}

static bool i2c_get_sda(volatile uint32_t *gpio_reg) {
    uint32_t val = *gpio_reg;
    val &= ~GPIO_DDC_DATA_EN;      // ç¦ç”¨è¾“å‡ºï¼ˆé«˜é˜»æ€ï¼Œç”¨äºè¯»å–ï¼‰
    *gpio_reg = val;
    val = *gpio_reg;
    return (val & GPIO_DDC_DATA_IN) != 0;
}

/**
 * è§£æ EDID é¦–é€‰åˆ†è¾¨ç‡ï¼ˆä»ç¬¬ä¸€ä¸ªè¯¦ç»†æ—¶åºæè¿°ç¬¦ï¼‰
 */
static void edid_parse_preferred_timing(const uint8_t *dtd, edid_info_t *info) {
    // è¯¦ç»†æ—¶åºæè¿°ç¬¦æ ¼å¼ï¼ˆ18 å­—èŠ‚ï¼‰
    // æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„æ—¶åºæè¿°ç¬¦ï¼ˆåƒç´ æ—¶é’Ÿ != 0ï¼‰
    uint16_t pixel_clock = dtd[0] | (dtd[1] << 8);
    if (pixel_clock == 0) {
        return;  // ä¸æ˜¯æ—¶åºæè¿°ç¬¦
    }
    
    // è§£ææ°´å¹³åˆ†è¾¨ç‡
    info->preferred_width = dtd[2] | ((dtd[4] & 0xF0) << 4);
    
    // è§£æå‚ç›´åˆ†è¾¨ç‡
    info->preferred_height = dtd[5] | ((dtd[7] & 0xF0) << 4);
    
    // è®¡ç®—åˆ·æ–°ç‡ï¼ˆåƒç´ æ—¶é’Ÿ / æ€»åƒç´ æ•°ï¼‰
    uint16_t h_total = info->preferred_width + (dtd[3] | ((dtd[4] & 0x0F) << 8));
    uint16_t v_total = info->preferred_height + (dtd[6] | ((dtd[7] & 0x0F) << 8));
    if (h_total > 0 && v_total > 0) {
        info->preferred_refresh = (pixel_clock * 10000UL) / (h_total * v_total);
    }
}

/**
 * è§£æ EDID æ•°æ®
 */
static void edid_parse(const uint8_t *data, edid_info_t *info) {
    // è§£æåˆ¶é€ å•† IDï¼ˆå‹ç¼© ASCIIï¼‰
    uint16_t mfg = (data[8] << 8) | data[9];
    info->manufacturer[0] = ((mfg >> 10) & 0x1F) + 'A' - 1;
    info->manufacturer[1] = ((mfg >> 5) & 0x1F) + 'A' - 1;
    info->manufacturer[2] = (mfg & 0x1F) + 'A' - 1;
    info->manufacturer[3] = '\0';
    
    // äº§å“ä»£ç å’Œåºåˆ—å·
    info->product_code = data[10] | (data[11] << 8);
    info->serial_number = data[12] | (data[13] << 8) | 
                          (data[14] << 16) | (data[15] << 24);
    
    // ç”Ÿäº§æ—¥æœŸ
    info->week = data[16];
    info->year = data[17] + 1990;
    
    // ç‰ˆæœ¬
    info->version = data[18];
    info->revision = data[19];
    
    // è§†é¢‘è¾“å…¥ç±»å‹
    info->is_digital = (data[20] & 0x80) != 0;
    
    // ç‰©ç†å°ºå¯¸
    info->max_horiz_size_cm = data[21];
    info->max_vert_size_cm = data[22];
    
    // è§£æé¦–é€‰åˆ†è¾¨ç‡ï¼ˆç¬¬ä¸€ä¸ªè¯¦ç»†æ—¶åºæè¿°ç¬¦ï¼Œåç§» 54ï¼‰
    edid_parse_preferred_timing(&data[54], info);
    
    // ä¿å­˜åŸå§‹æ•°æ®
    memcpy(info->raw, data, EDID_BLOCK_SIZE);
    info->valid = true;
}

/**
 * éªŒè¯ EDID æ ¡éªŒå’Œ
 */
bool edid_validate(const uint8_t *data) {
    // æ£€æŸ¥ EDID å¤´
    static const uint8_t edid_header[] = {0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00};
    if (memcmp(data, edid_header, 8) != 0) {
        return false;
    }
    
    // æ ¡éªŒå’Œ
    uint8_t sum = 0;
    for (int i = 0; i < EDID_BLOCK_SIZE; i++) {
        sum += data[i];
    }
    return sum == 0;
}

/**
 * æ‰“å° EDID ä¿¡æ¯
 */
void edid_print_info(const edid_info_t *info) {
    if (!info->valid) {
        kprintf("EDID: Invalid or not available\n");
        return;
    }
    
    kprintf("EDID Information:\n");
    kprintf("  Manufacturer: %s\n", info->manufacturer);
    kprintf("  Product Code: 0x%04X\n", info->product_code);
    kprintf("  Serial: %u\n", info->serial_number);
    kprintf("  Manufactured: Week %d, %d\n", info->week, info->year);
    kprintf("  EDID Version: %d.%d\n", info->version, info->revision);
    kprintf("  Display Type: %s\n", info->is_digital ? "Digital" : "Analog");
    kprintf("  Physical Size: %d x %d cm\n", info->max_horiz_size_cm, info->max_vert_size_cm);
    kprintf("  Native Resolution: %dx%d @ %dHz\n", 
            info->preferred_width, info->preferred_height, info->preferred_refresh);
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```c
// åœ¨å†…æ ¸åˆå§‹åŒ–æ—¶è¯»å– EDID
edid_info_t edid;
if (edid_read(&edid) == 0 && edid.valid) {
    edid_print_info(&edid);
    
    // éªŒè¯å½“å‰åˆ†è¾¨ç‡æ˜¯å¦ä¸ºåŸç”Ÿåˆ†è¾¨ç‡
    framebuffer_info_t *fb = fb_get_info();
    if (fb->width != edid.preferred_width || fb->height != edid.preferred_height) {
        LOG_WARN_MSG("Warning: Current resolution %dx%d differs from native %dx%d\n",
                     fb->width, fb->height, 
                     edid.preferred_width, edid.preferred_height);
    }
}
```

### æ­¥éª¤ 6: é›†æˆåˆ°å†…æ ¸

**æ›´æ–°æ–‡ä»¶**: `src/kernel/kernel.c`

```c
// ============================================================================
// kernel.c - å†…æ ¸ä¸»å‡½æ•°ï¼ˆæ”¯æŒå¤šåˆ†è¾¨ç‡å›¾å½¢æ¨¡å¼ï¼‰
// ============================================================================

// ... å…¶ä»– include ...
#include <drivers/pci.h>
#include <drivers/framebuffer.h>
#include <drivers/edid.h>

void kernel_main(multiboot_info_t* mbi) {
    // ========================================================================
    // é˜¶æ®µ 0: æ—©æœŸåˆå§‹åŒ–
    // ========================================================================    
    vga_init(); // åˆå§‹åŒ– VGAï¼ˆæ–‡æœ¬æ¨¡å¼å¤‡ç”¨ï¼‰
    serial_init(); // åˆå§‹åŒ–ä¸²å£
    
    // ========================================================================
    // é˜¶æ®µ 4: è®¾å¤‡é©±åŠ¨ï¼ˆDevice Driversï¼‰
    // ========================================================================
    
    LOG_INFO_MSG("[Stage 4] Initializing device drivers...\n");
    
    // ... å…¶ä»–é©±åŠ¨åˆå§‹åŒ– ...
    
    // 4.5 åˆå§‹åŒ– PCI æ€»çº¿
    pci_init();
    int pci_count = pci_scan_devices();
    LOG_INFO_MSG("  [4.5] PCI initialized, found %d devices\n", pci_count);
    pci_print_devices();
    
    // 4.6 åˆå§‹åŒ–å›¾å½¢é©±åŠ¨ï¼ˆæ”¯æŒå¤šåˆ†è¾¨ç‡ï¼‰
    if (fb_init_from_multiboot(mbi) == 0) {
        framebuffer_info_t *fb = fb_get_info();
        LOG_INFO_MSG("  [4.6] Framebuffer initialized: %dx%d @ %dbpp\n",
                     fb->width, fb->height, fb->bpp);
        
        // æ ¹æ®åˆ†è¾¨ç‡æ˜¾ç¤ºä¸åŒçš„ä¿¡æ¯
        const char *resolution_name;
        if (fb->width == 1400 && fb->height == 1050) {
            resolution_name = "SXGA+ (1400x1050)";
        } else if (fb->width == 1024 && fb->height == 768) {
            resolution_name = "XGA (1024x768)";
        } else {
            resolution_name = "Custom";
        }
        LOG_INFO_MSG("  Display mode: %s\n", resolution_name);
        
        // 4.7 è¯»å– EDID éªŒè¯åŸç”Ÿåˆ†è¾¨ç‡ï¼ˆå¯é€‰ï¼‰
        edid_info_t edid;
        if (edid_read(&edid) == 0 && edid.valid) {
            LOG_INFO_MSG("  [4.7] EDID: Native resolution %dx%d\n",
                         edid.preferred_width, edid.preferred_height);
            
            // æ£€æŸ¥æ˜¯å¦ä½¿ç”¨åŸç”Ÿåˆ†è¾¨ç‡
            if (fb->width != edid.preferred_width || 
                fb->height != edid.preferred_height) {
                LOG_WARN_MSG("  Warning: Not using native resolution!\n");
            }
        }
        
        // æµ‹è¯•ï¼šæ¸…å±å¹¶ç»˜åˆ¶å›¾å½¢ï¼ˆä½ç½®æ ¹æ®åˆ†è¾¨ç‡è‡ªé€‚åº”ï¼‰
        fb_clear(COLOR_BLACK);
        int center_x = fb->width / 2 - 100;
        int center_y = fb->height / 2 - 50;
        fb_fill_rect(center_x, center_y, 200, 100, COLOR_BLUE);
        fb_draw_string(center_x + 10, center_y + 40, 
                       "CastorOS Graphics Mode!", COLOR_WHITE, COLOR_BLUE);
        
        // æ˜¾ç¤ºåˆ†è¾¨ç‡ä¿¡æ¯
        char res_info[64];
        ksnprintf(res_info, sizeof(res_info), "Resolution: %dx%d", fb->width, fb->height);
        fb_draw_string(10, 10, res_info, COLOR_WHITE, COLOR_BLACK);
    } else {
        LOG_WARN_MSG("  [4.6] Framebuffer not available, using text mode\n");
    }
    
    // ... å…¶ä½™åˆå§‹åŒ–ä»£ç  ...
}
```

---

## æµ‹è¯•è®¡åˆ’

### å•å…ƒæµ‹è¯•

1. **PCI æµ‹è¯•**
   - éªŒè¯ PCI é…ç½®ç©ºé—´è¯»å†™æ­£ç¡®æ€§
   - éªŒè¯è®¾å¤‡æšä¸¾å®Œæ•´æ€§
   - éªŒè¯ BAR è§£ææ­£ç¡®æ€§

2. **å¸§ç¼“å†²æµ‹è¯•**
   - éªŒè¯åƒç´ ç»˜åˆ¶æ­£ç¡®æ€§
   - éªŒè¯çŸ©å½¢å¡«å……æ­£ç¡®æ€§
   - éªŒè¯æ–‡æœ¬æ¸²æŸ“æ­£ç¡®æ€§
   - éªŒè¯é¢œè‰²æ ¼å¼è½¬æ¢

### é›†æˆæµ‹è¯•

1. **å›¾å½¢æ¨¡å¼å¯åŠ¨æµ‹è¯•**
   - éªŒè¯ GRUB æ­£ç¡®è®¾ç½®å›¾å½¢æ¨¡å¼
   - éªŒè¯ Multiboot ä¿¡æ¯æ­£ç¡®ä¼ é€’
   - éªŒè¯å¸§ç¼“å†²æ˜ å°„æ­£ç¡®

2. **å¤šåˆ†è¾¨ç‡æµ‹è¯•**
   - åœ¨ QEMU ä¸­æµ‹è¯• 1024Ã—768 æ¨¡å¼
   - åœ¨ QEMU ä¸­æµ‹è¯• 1400Ã—1050 æ¨¡å¼
   - éªŒè¯ GRUB åˆ†è¾¨ç‡å›é€€æœºåˆ¶
   - éªŒè¯åˆ†è¾¨ç‡è‡ªé€‚åº” UI å¸ƒå±€

3. **EDID æµ‹è¯•**
   - éªŒè¯ EDID è¯»å–æ­£ç¡®æ€§
   - éªŒè¯åŸç”Ÿåˆ†è¾¨ç‡æ£€æµ‹
   - æµ‹è¯•æ—  EDID æ—¶çš„ä¼˜é›…é™çº§

4. **ç¡¬ä»¶æµ‹è¯•**
   - åœ¨ VirtualBox ä¸­æµ‹è¯•
   - åœ¨å®é™… ThinkPad T41 XGA å±å¹•ä¸Šæµ‹è¯•
   - åœ¨å®é™… ThinkPad T41 SXGA+ å±å¹•ä¸Šæµ‹è¯•

### Shell å‘½ä»¤

```
lspci           - åˆ—å‡ºæ‰€æœ‰ PCI è®¾å¤‡
fbtest          - è¿è¡Œå¸§ç¼“å†²æµ‹è¯•
fbinfo          - æ˜¾ç¤ºå¸§ç¼“å†²ä¿¡æ¯ï¼ˆåˆ†è¾¨ç‡ã€é¢œè‰²æ·±åº¦ã€ç‰©ç†åœ°å€ï¼‰
edid            - æ˜¾ç¤º EDID ä¿¡æ¯ï¼ˆåˆ¶é€ å•†ã€åŸç”Ÿåˆ†è¾¨ç‡ï¼‰
gfxdemo         - è¿è¡Œå›¾å½¢æ¼”ç¤ºï¼ˆè‡ªé€‚åº”å½“å‰åˆ†è¾¨ç‡ï¼‰
```

---

## é™åˆ¶å’Œæœªæ¥æ”¹è¿›

### å½“å‰é™åˆ¶

1. ä»…æ”¯æŒ Multiboot æä¾›çš„å›¾å½¢æ¨¡å¼
2. ä¸æ”¯æŒè¿è¡Œæ—¶æ¨¡å¼åˆ‡æ¢
3. ä¸æ”¯æŒç¡¬ä»¶åŠ é€Ÿ
4. å­—ä½“æ¸²æŸ“ç®€å•ï¼ˆæ— æŠ—é”¯é½¿ï¼‰
5. æ—  2D/3D åŠ é€Ÿ

### æœªæ¥æ”¹è¿›

1. **æ¨¡å¼åˆ‡æ¢**
   - å®ç° V86 æ¨¡å¼è°ƒç”¨ VBE BIOS
   - æ”¯æŒè¿è¡Œæ—¶åˆ†è¾¨ç‡åˆ‡æ¢

2. **ATI åŸç”Ÿé©±åŠ¨**
   - ç›´æ¥æ“ä½œ Radeon å¯„å­˜å™¨
   - å®ç° 2D åŠ é€Ÿï¼ˆçŸ©å½¢å¡«å……ã€ä½å—ä¼ è¾“ï¼‰
   - å®ç°ç¡¬ä»¶å…‰æ ‡

3. **GUI æ¡†æ¶**
   - çª—å£ç®¡ç†å™¨
   - é¼ æ ‡æ”¯æŒ
   - æ§ä»¶åº“

4. **é«˜çº§æ¸²æŸ“**
   - æŠ—é”¯é½¿å­—ä½“ï¼ˆFreeTypeï¼‰
   - Alpha æ··åˆ
   - å›¾ç‰‡æ ¼å¼æ”¯æŒï¼ˆBMPã€PNGï¼‰

---

## æ–‡ä»¶æ¸…å•

### æ–°å¢æ–‡ä»¶

- `src/include/drivers/pci.h` - PCI æ€»çº¿é©±åŠ¨å¤´æ–‡ä»¶
- `src/drivers/pci.c` - PCI æ€»çº¿é©±åŠ¨å®ç°
- `src/include/drivers/framebuffer.h` - å¸§ç¼“å†²é©±åŠ¨å¤´æ–‡ä»¶
- `src/drivers/framebuffer.c` - å¸§ç¼“å†²é©±åŠ¨å®ç°
- `src/include/drivers/edid.h` - EDID è¯»å–é©±åŠ¨å¤´æ–‡ä»¶
- `src/drivers/edid.c` - EDID è¯»å–é©±åŠ¨å®ç°
- `src/include/drivers/radeon.h` - ATI Radeon é©±åŠ¨å¤´æ–‡ä»¶ï¼ˆå¯é€‰ï¼‰
- `src/drivers/radeon.c` - ATI Radeon é©±åŠ¨å®ç°ï¼ˆå¯é€‰ï¼‰

### ä¿®æ”¹æ–‡ä»¶

- `src/boot/multiboot.asm` - æ·»åŠ å›¾å½¢æ¨¡å¼è¯·æ±‚ï¼ˆæ”¯æŒå¤šåˆ†è¾¨ç‡ï¼‰
- `src/include/kernel/multiboot.h` - æ·»åŠ å¸§ç¼“å†²ç›¸å…³å­—æ®µ
- `src/kernel/kernel.c` - é›†æˆå›¾å½¢åˆå§‹åŒ–å’Œ EDID æ£€æµ‹
- `grub.cfg` - é…ç½®å¤šåˆ†è¾¨ç‡å›¾å½¢æ¨¡å¼
- `Makefile` - æ·»åŠ æ–°æ–‡ä»¶ç¼–è¯‘è§„åˆ™

---

## å‚è€ƒèµ„æ–™

1. [OSDev - PCI](https://wiki.osdev.org/PCI)
2. [OSDev - VESA Video Modes](https://wiki.osdev.org/VESA_Video_Modes)
3. [OSDev - Drawing In Protected Mode](https://wiki.osdev.org/Drawing_In_Protected_Mode)
4. [Multiboot Specification](https://www.gnu.org/software/grub/manual/multiboot/multiboot.html)
5. [ATI Radeon Register Reference](https://www.x.org/docs/AMD/)
